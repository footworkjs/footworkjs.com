<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>A viewModel can be thought of as a container object that houses all of the logic and data with which your template/HTML/DOM binds to. They are used to 'wrap' your
        HTML/markup, applying the bindings (behavior) you declare in the HTML while also initializing and binding any nested components and viewModels.</p>

      <p>In knockout.js you typically need to manually wrap and bind (<span class="inline-code">ko.applyBindings()</span>) your DOM with instances of your viewModels,
        this has many disadvantages/issues (primarily, it requires a lot of legwork by you). Footwork.js can handle the initialization, wrapping, and binding for you
        automatically based on the HTML/DOM (<em>it can also autoload them via AMD/RequireJS as needed</em>).</p>

      <p>In addition, they can contain any number of nested viewModels, components, and any other markup...making them extremely powerful (especially when integrated into a
        <a data-bind="$route: docLink('components')">component</a>).</p>

      <p>There are a number of ways to create viewModels, but a simple plain old javascript object (just as in normal knockout.js) at its most basic level is all that is
        needed to bind to the DOM.</p>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Usage</h2>
    </header>
    <div class="content">
      <p>A <span class="inline-code">viewModel</span> can be used in 3 different ways:</p>
      <ul>
        <li>Manually initialized (standard knockout methodology), and optionally bound to the DOM.</li>

        <li>Automatically via a <span class="inline-code">&lt;dataModel module="[moduleName]"&gt; ... &lt;/dataModel&gt;</span> declaration in the DOM.</li>

        <li>Automatically via a <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM (See:
          <a data-bind="$route" href="#inside-component">&lt;component&gt; usage</a>).</li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>Each different type of viewModel you wish to have must have a new constructor function made for it.</p>

      <p>viewModel constructor functions are created by calling the factory method <span class="inline-code">fw.viewModel()</span> and passing it a configuration object.</p>

      <p>The resulting constructor function can then be used to instantiate new instances of that viewModel.
        These constructor functions are essentially specialized wrappers which enable footwork to hook into both knockout and your viewModel/module to provide for all of
        the additional features the framework provides.</p>

      <h3><em class="func-def">fw.viewModel<span>( <span class="param">configurationObject</span> )</span></em></h3>
      <h3>create a <span class="inline-code">viewModel</span> constructor function:</h3>
<pre><code class="javascript">var ViewModelConstructor = fw.viewModel({
  /**
   * The namespace (communications channel) the viewModel uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   */
  namespace: 'Sprocket', // example namespace name, any alpha-numeric is valid

  /**
   * If true, footwork will register the viewModel under its namespace name. This means
   * that when this fw.viewModel() call is made it will automatically call
   * fw.viewModels.register('Sprocket', ThisViewModelConstructor)
   * This is a (handy) way of telling footwork how to find your viewModel when it needs it.
   */
  autoRegister: false, // default === false

  /**
   * If true, the namespace will have an auto-incremented 0-based index number appended for
   * each new viewModel (ie: new instances will not share the same namespace).
   */
  autoIncrement: false, // default === false

  /**
   * Initialization function called at creation of a new viewModel.
   * Note: it is passed in the parameters supplied at creation.
   */
  initialize: function(param1, param2, ...) {
    // this === the viewModel object
    // Perform normal viewModel initialization here, just like typical knockout.js code.
    this.param1 = fw.observable(param1);
  },

  // Behavioral mixins to include with each new viewModel created
  mixins: [
    // See: 'Mixins' section on this page
  ],

  // Function called just after binding to the DOM
  afterBinding: function(containingElement) {
    // this === the viewModel object
  },

  // Function called just before the html this viewModel is bound to is removed from the DOM
  onDispose: function(containingElement) {
    // this === the viewModel object
  }
});</code></pre>
    </div>
  </section>

  <a id="bind-manually" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="bind-manually">
    <div class="highlight"></div>
    <header>
      <h2>Manual Instantiation and Binding:</h2>
    </header>
    <div class="content">
      <p>Manually instantiating a <span class="inline-code">viewModel</span> is done by calling <span class="inline-code">new ConstructorFunc()</span>.
        With the instance in hand you can then use it as you wish, either directly or by binding it to the DOM.</p>

      <p>To manually bind a <span class="inline-code">viewModel</span> you use a <span class="inline-code">fw.applyBindings()</span>
        call after instantiating it.</p>
<pre><code class="javascript">var Sprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(params) {
    // params === object passed in when calling new Sprocket()
    this.type = fw.observable(params.type);
    this.color = params.color || 'orange';
    this.price = fw.observable(params.price);
    this.isExpensive = fw.computed(function() {
      return this.price() > 10;
    }, this);
  }
});

var awesomeSprocket = new Sprocket({ type: 'awesome', price: 3.50 });
// awesomeSprocket.type() === 'awesome'
// awesomeSprocket.color === 'orange'
// awesomeSprocket.isExpensive() === false
</code></pre>

      <p>Now, if we wish, we can bind the <span class="inline-code">Sprocket</span> instance (<span class="inline-code">awesomeSprocket</span>) to the DOM:</p>
<pre><code class="javascript">fw.applyBindings(awesomeSprocket, document.getElementById('sprocket-container'));</code></pre>
    </div>
  </section>

  <a id="viewModel-element" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="viewModel-element">
    <div class="highlight"></div>
    <header>
      <h2>Automatic initialization via <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM:</h2>
    </header>
    <div class="content">
      <p>A <span class="inline-code">viewModel</span> can be instantiated and bound automatically when using a
        <span class="inline-code">&lt;viewModel&gt;</span> declarative wrapper element. Using the <span class="inline-code">module=""</span> attribute
        you can specify which <span class="inline-code">viewModel</span> should be instantiated and bound by footwork.</p>
<pre><code class="html">&lt;viewModel module="Person"&gt;
  &lt;form&gt;
    &lt;label&gt;First Name: &lt;input type="text" data-bind="value: firstName"&gt;&lt;/label&gt;
    &lt;label&gt;Last Name: &lt;input type="text" data-bind="value: lastName"&gt;&lt;/label&gt;
    &lt;input type="submit" value="Save"&gt;
  &lt;/form&gt;
&lt;/viewModel&gt;</code></pre>

          <p>... and as an example, this <span class="inline-code">viewModel</span> was registered directly:</p>
<pre><code class="javascript">fw.viewModels.register('Person', fw.viewModel({
    namespace: 'Person',
    initialize: function(params) {
      this.firstName = fw.observable(params.firstName);
    }
  })
);
</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> You can have your <span class="inline-code">viewModel</span> automatically downloaded for you when needed.</p>
        <p>See <a data-bind="$route" href="#registration">viewModel registration</a>
          for information on how to tell footwork where to find your component assets.</p>
      </div>
    </div>
  </section>

  <a id="inside-component" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="inside-component">
    <div class="highlight"></div>
    <header>
      <h2>Automatic initialization via <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM:</h2>
    </header>
    <div class="content">
      <p>You can supply a <span class="inline-code">viewModel</span> inside of a component registration (or location registration). By doing that the
        component will bind the <span class="inline-code">viewModel</span> against your markup.</p>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;!-- NOTE: Both the viewModel and template are either autoloaded via requireJS/AMD, or
               loaded from cache/configuration you supply to the framework --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

          <p>... and as an example, this <span class="inline-code">component</span> was registered directly:</p>
<pre><code class="javascript">fw.components.register('sprocket', {
  viewModel: fw.viewModel({
    namespace: 'Sprocket',
    initialize: function(params) {
      this.type = fw.observable(params.type);
    }
  }),
  template: '&lt;!-- component HTML markup --&gt;'
});
</code></pre>

      <div class="note">
        <p><span class="label">NOTE:</span> You can have your <span class="inline-code">component</span> automatically downloaded for you when needed.</p>
        <p>See <a data-bind="$route: docLink('components#loading-registering')">component AMD / Lazy Loading / Registering</a>
          for information on how to tell footwork where to find your component assets.</p>
      </div>
    </div>
  </section>

  <a id="lifecycle-registration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="lifecycle-registration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lifecycle &amp; Registration</h2>
    </header>
    <div class="content">
      <p>Each <span class="inline-code">viewModel</span> instantiated and bound to the DOM will receive lifecycle events.</p>
      <p>These events can be used for any code you need to run when the instance is initially setup on or removed from the page. A common example
        would be the setup and teardown of a jQuery plugin, or events.</p>
    </div>
  </section>

  <a id="lifecycle-registration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="lifecycle-registration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lifecycle &amp; Registration</h2>
    </header>
    <div class="content">
      <p>Each <span class="inline-code">dataModel</span> instantiated and bound to the DOM will receive lifecycle events.</p>
      <p>These events can be used for any code you need to run when the instance is initially setup on or removed from the page. A common example
        would be the setup and teardown of a jQuery plugin, or events.</p>
    </div>
  </section>

  <a id="lifecycle" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="lifecycle">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lifecycle</h2>
    </header>
    <div class="content">
      <p>Lifecycle events are automatically handled for you when using a <span class="inline-code">viewModel</span> via one of the three main methods:</p>

      <ul>
        <li>Use the <span class="inline-code">&lt;viewModel&gt; ... &lt;/viewModel&gt;</span> declarative syntax.</li>
        <li>Use the <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declarative syntax.</li>
        <li>Manually bound (<span class="inline-code">fw.applyBindings()</span>) to the DOM.</li>
      </ul>

      <p>A viewModel that is attached to the DOM will retrive two main lifecycle events, one just after binding to the DOM
        (<span class="inline-code">afterBinding()</span>) and one when the element (that the viewModel bound itself to) is removed from the DOM
        (<span class="inline-code">onDispose()</span>, called just before the element is removed).</p>

      <div class="note"><span class="label">NOTE:</span> Any subscriptions, namespaces, events, etc must be assigned to the instance if you
        want them to automatically be cleaned up for you when the viewModel is disposed.</div>

<pre><code class="javascript">var someOtherObservable = fw.observable();

var MyViewModel = fw.viewModel({
  initialize: function() {
    this.myVarSub = someOtherObservable.subscribe(function() {
      // This subscription will get cleaned up when the viewModel is disposed
    });

    this.$namespace.command.handler('doSomething', function() {
      // This command handler will get cleaned up when the viewModel is disposed
    });

    this.$someOtherNamespace = fw.namespace('SomeOtherNamespace');
    this.$someOtherNamespace.command.handler('doSomethingElse', function() {
      // This command handler will get cleaned up when the viewModel is disposed
    });

    this.someOtherThing = {
      eventHandler: this.$namespace.event.handler('someEvent', function() {
        // This will NOT get cleaned up, handler result/subscription is not attached to 'this'
      })
    };
  }
});
</code></pre>

      <a id="viewModel-dispose" class="section-anchor" data-bind="sectionAnchor"></a>
      <h3><em class="func-def">viewModel.dispose<span>()</span></em></h3>
      <p>If you do not bind a viewModel to the DOM then you will want to clean up its references and subscriptions when you are done with it. This is done
        by calling <span class="inline-code">viewModel.dispose()</span> directly.</p>
      <h3>Dispose of all namespaces, handlers, and subscriptions assigned to a viewModel:</h3>
<pre><code class="javascript">var MyViewModel = fw.viewModel({ /* ... */ });
var viewModel = new MyViewModel();
// ...
viewModel.dispose(); // all namespaces, handlers, and subscriptions now cleaned up/removed
</code></pre>
    </div>
  </section>

  <a id="afterBinding" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="afterBinding">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">afterBinding()</h2>
    </header>
    <div class="content">
      <p>If provided, the <span class="inline-code">viewModel</span> configuration <span class="inline-code">afterBinding()</span> method will be called
        just after a <span class="inline-code">viewModel</span> is bound to the DOM. This provides a handy integration point for external libraries or
        plugins (such as jQuery).</p>

<pre><code class="javascript">var Person = fw.viewModel({
  namespace: 'Person',
  afterBinding: function(domElement) {
    var person = this;
    domElement.addEventListener('click', function() {
      console.info('You clicked', person.firstName());
    });
  },
  initialize: function(params) {
    this.firstName = fw.observable().mapTo('firstName');
  }
});
</code></pre>

  <a id="onDispose" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="onDispose">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">onDispose()</h2>
    </header>
    <div class="content">
      <p>If provided, the <span class="inline-code">viewModel</span> configuration <span class="inline-code">onDispose()</span> method will be called
        just after the element a <span class="inline-code">viewModel</span> is bound to is removed from the DOM. This provides a handy integration
        point for external libraries or plugins (such as jQuery).</p>

<pre><code class="javascript">var Person = fw.viewModel({
  namespace: 'Person',
  afterBinding: function(domElement) {
    domElement.addEventListener('click', this.clickPerson);
  },
  onDispose: function(domElement) {
    domElement.removeEventListener('click', this.clickPerson);
  },
  initialize: function(params) {
    var person = this;
    this.firstName = fw.observable(params.firstName).mapTo('firstName');
    this.clickPerson = function() {
      console.info('You clicked', person.firstName());
    };
  }
});
</code></pre>

      <a id="viewModel-dispose" class="section-anchor" data-bind="sectionAnchor"></a>
      <h3><em class="func-def">viewModel.dispose<span>()</span></em></h3>
      <p>If you do not bind a viewModel to the DOM then you will want to tell it to clean up its references when you are getting rid of it. This is done
        by calling <span class="inline-code">viewModel.dispose()</span> directly.</p>
      <h3>Dispose of all namespaces, handlers, and subscriptions assigned to a viewModel:</h3>
<pre><code class="javascript">var MyViewModel = fw.viewModel({ /* ... */ });
var viewModel = new MyViewModel();
// ...
viewModel.dispose(); // all namespaces, handlers, and subscriptions now cleaned up/removed
</code></pre>
    </div>
  </section>

  <a id="registration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="registration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Registration</h2>
    </header>
    <div class="content">
      <p>In order for footwork to know what to do when it encounters a <span class="inline-code">&lt;viewModel&gt;</span> it must be registered in some
        way.</p>

      <p>Footwork supports both explicitly registering your <span class="inline-code">viewModel</span> ahead of time (caching it directly) or
        automatically/lazily loading via AMD/RequireJS.</p>

      <p>That is done with one of the following methods:</p>

      <ul>
        <li><span class="inline-code"><a data-bind="$route" href="#viewModels-register">fw.viewModels.register()</a></span> - Register (cache) a
          <span class="inline-code">viewModel</span> explicitly.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#viewModels-registerLocation">fw.viewModels.registerLocation()</a></span> - Register the location of a
          <span class="inline-code">viewModel</span> so that it can be dynamically loaded at some time in the future.</li>
      </ul>

      <p>In either case, the declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span>
        syntax will trigger the loading (if necessary), instantiation, and binding of the <span class="inline-code">viewModel</span>.</p>

      <div class="note">
        <p><span class="label">NOTE:</span> AMD/RequireJS is fully supported (and highly encouraged) for a number of reasons:</p>

        <ul>
          <li>It strongly encourages modularization and separation of concerns.</li>

          <li>Helps decouple your application and allow for easier testability.</li>

          <li>Footwork can take advantage of its dependency resolution to automatically load and use resources for you as needed at runtime (<em>including the automatic
            loading and composing of entire views/pages/routes, components, or viewModels</em>).</li>

          <li>Allows for easier debugging as non-compiled assets while still being buildable for release into a production environment.</li>

          <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, and templates). None, some, or all of
            it...you choose what your users wait for.</li>
        </ul>
      </div>

      <p>To load and bind a section of your DOM with a <span class="inline-code">viewModel</span>, insert/wrap the HTML with a
        <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element.</p>

      <h3>Example <span class="inline-code">&lt;viewModel&gt;</span> wrapper:</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Person"&gt;
      &lt;!-- HTML to be bound using an instance of the viewModel/module --&gt;
      Hello &lt;span data-bind="text: firstName"&gt;&lt;/span&gt;!
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <div class="note">
        <span class="label">NOTE:</span> You can nest <span class="inline-code">viewModels</span>, <span class="inline-code">viewModels</span>, and
        <span class="inline-code">components</span> within one another.
      </div>
    </div>
  </section>

  <a id="module-resolution" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="module-resolution">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Module Resolution</h2>
    </header>
    <div class="content">
      <p>There are 3 ways footwork will try to resolve your <span class="inline-code">viewModel</span> when it encounters the declarative
        <span class="inline-code">&lt;dataModel module="[moduleName]"&gt; ... &lt;/dataModel&gt;</span> element you place in the DOM.</p>

      <p>Here they are in order of priority:</p>

      <ul>
        <li>Explicitly registered with a <span class="inline-code">fw.dataModels.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.dataModels.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.dataModels.defaultLocation()</span>).</li>
      </ul>

      <p>Registering a dataModel explicitly with <span class="inline-code">fw.dataModels.register()</span> makes it immediately available. Any
        <span class="inline-code">&lt;dataModel module="[moduleName]"&gt; ... &lt;/dataModel&gt;</span> declarations encountered will be processed with no delay
        (the dataModel is 'cached' when registered).</p>

      <p>The 2 methods <span class="inline-code">registerLocation()</span> and <span class="inline-code">defaultLocation()</span> tell footwork where it can
        download your dataModel module (in the event you do not explicitly register it). In any case your markup will wait until the dataModel is resolved prior
        to being initialized.</p>

      <div class="note"><span class="label">NOTE:</span> Nested dataModels and components are independently resolved. It works as you would expect, with an
        outer-most container (dataModel/component) initializing/processing/binding and rendering, then any nested dataModels/components get initialized (and so
        forth until the end).</div>

      <a id="dataModels-register" class="section-anchor" data-bind="sectionAnchor"></a>
      <h3><em class="func-def">fw.dataModels.register<span>( <span class="param">'moduleName'</span>, <span class="param">dataModel</span> )</span></em></h3>
      <h3>Cache a dataModel/module ahead of time:</h3>
<pre><code class="javascript">// register a footwork dataModel
var Person = fw.dataModel({ /* configuration object */ });
fw.dataModels.register('Person', Person);

// register a normal class constructor function (like in regular knockout)
var Person = function() { this.isUsed = fw.observable(false); };
fw.dataModels.register('Person', Person);

// register an instance of an object (like in regular knockout)
fw.dataModels.register('Person', {
  instance: { isUsed: false } // object representing the dataModel to be bound against the DOM
});

/**
 * A constructor function to be called when the declaration is encountered.
 * It is supplied params given at the binding (&lt;dataModel params="exampleParam: true"&gt;) and
 * the containing element of the dataModel.
 */
fw.dataModels.register('Person', {
  createdataModel: function(params, info) {
    // info.element = containing &lt;dataModel&gt; element
    // params are the parameters declaratively created from the DOM (See: note below)
    return { isUsed: false }; // object representing the dataModel to be bound against the DOM
  }
});</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> Are you using a fw.dataModel() constructor and simply want to register it using the namespace name (recommended)?</p>

        <p>You can optionally just set <span class="inline-code">autoRegister: true</span> in the dataModel configuration object, then the fw.dataModel.register
          call is taken care of for you when the dataModel constructor is created.</p>

        <p>See: <a data-bind="$route" href="#configuration">dataModel configuration</a>.</p>
      </div>

      <a id="dataModels-registerLocation" class="section-anchor" data-bind="sectionAnchor"></a>
      <h3><em class="func-def">fw.dataModels.registerLocation<span>( <span class="param">'moduleName'</span>, <span class="param">'path/to/module'</span> )</span></em></h3>
      <h3>Register the location of a dataModel/module so footwork can load and bind it for you when needed:</h3>
<pre><code class="javascript">// Load Person from: /dataModels/Person.js (based on dataModel/module name, case sensitive)
fw.dataModels.registerLocation('Person', '/dataModels/');

// Load Person from: /dataModels/DifferentFileName.js (specify full file name)
fw.dataModels.registerLocation('Person', '/dataModels/DifferentFileName.js');

// register the location of several dataModels at once (ie: all in the same folder)
fw.dataModels.registerLocation(['Reservations', 'Invoices', 'Notes'], '/dataModels/stuff/');</code></pre>

      <h3>Example AMD/RequireJS enhanced footwork module:</h3>
<pre><code class="javascript">/**
 * An AMD/RequireJS module is defined in exactly the same way as a normal knockout module would be.
 * The only difference being that you return the footwork-flavored dataModel constructor function
 * result from fw.dataModel() instead of a normal (function() {}) constructor.
 */
define(["footwork"],
  function(fw) {
    return fw.dataModel({
      // ... configuration object ...
      namespace: 'Person',

      /**
       * [optional] This module will now automatically register itself as 'Person' and footwork
       * can autoload and bind it as soon as it is pulled in via AMD.
       *
       * This is an easy way to autoload and cache your dataModels for declarative use in your HTML.
       */
      autoRegister: true,

      initialize: function() {
        this.isUsed = fw.observable(false);
      }
    });
  }
);</code></pre>

      <h3><em class="func-def">fw.dataModels.defaultLocation<span>( <span class="param">'path/to/dataModel/folder'</span> )</span></em></h3>
      <h3>Register the default location of dataModels/modules so footwork can load and bind them for you when needed:</h3>
<pre><code class="javascript">// Load all dataModels from /mydataModels/[module-name].js (case sensitive)
fw.dataModels.defaultLocation('/mydataModels/');</code></pre>
    </div>
  </section>

  <!-- ******************************************************* -->

  <a id="loading-registering" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="loading-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading / Registering</h2>
    </header>
    <div class="content">
      <p>footwork.js supports both explicitly registering your viewModels ahead of time or automatically loading via AMD/RequireJS. In either case, the
        declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> syntax will trigger the loading (if necessary),
        initialization, and binding of the viewModel/module.</p>

      <p>AMD/RequireJS is fully supported (and highly encouraged) for a number of reasons:</p>

      <ul>
        <li>It strongly encourages modularization and separation of concerns.</li>

        <li>Helps decouple your application and allow for easier testability.</li>

        <li>footwork can take advantage of its dependency resolution to automatically load and use resources for you as needed at runtime (<em>including the automatic
          loading and composing of entire views/pages/routes, components, or viewModels</em>).</li>

        <li>Allows for easier debugging as non-compiled assets while still being buildable for release into a production environment.</li>

        <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, and templates). None, some, or all of
          it...you choose what your users wait for.</li>
      </ul>

      <h3>Example AMD/RequireJS enhanced footwork module:</h3>
<pre><code class="javascript">/**
 * An AMD/RequireJS module is defined in exactly the same way as a normal knockout module would be.
 * The only difference being that you return the footwork-flavored viewModel constructor function
 * result from fw.viewModel() instead of a normal function() {} constructor.
 */
define(["footwork"],
  function(fw) {
    return fw.viewModel({
      // ... configuration object ...
      namespace: 'Sprocket',

      /**
       * [optional] This module will now automatically register itself as 'Sprocket' and footwork
       * can autoload and bind it as soon as it is pulled in via AMD.
       *
       * This is an easy way to autoload and cache your viewModels for declarative use in your HTML.
       */
      autoRegister: true,

      initialize: function() {
        this.isUsed = fw.observable(false);
      }
    });
  }
);</code></pre>

      <p>Automatically loading and binding a section of your DOM with a viewModel begins with inserting/wrapping the html in your template with a
        <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element.</p>

      <h3>Example <span class="inline-code">&lt;viewModel&gt;</span> wrapper:</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="[moduleName]"&gt;
      &lt;!-- HTML to be bound using an instance of the viewModel/module --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> You can nest viewModels and components within one another.</p>

      <h3>viewModel/module resolution</h3>

      <p>There are 3 ways footwork will try to resolve your viewModel when it encounters the declarative
        <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element you place in the DOM.</p>

      <p>Here they are in order of priority:</p>

      <ul>
        <li>Explicitly registered with a <span class="inline-code">fw.viewModels.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.viewModels.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.viewModels.defaultLocation()</span>).</li>
      </ul>

      <p>Registering a viewModel explicitly with <span class="inline-code">fw.viewModels.register()</span> makes it immediately available. Any
        <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declarations encountered will be processed with no delay
        (the viewModel is 'cached' when registered).</p>

      <p>The 2 methods <span class="inline-code">registerLocation()</span> and <span class="inline-code">defaultLocation()</span> tell footwork where it can
        download your viewModel module (in the event you do not explicitly register it). In any case your markup will wait until the viewModel is resolved prior
        to being initialized.</p>

      <div class="note"><span class="label">NOTE:</span> Nested viewModels and components are independently resolved. It works as you would expect, with an
        outer-most container (viewModel/component) initializing/processing/binding and rendering, then any nested viewModels/components get initialized (and so
        forth until the end).</div>

      <h3><em class="func-def">fw.viewModels.register<span>( <span class="param">'moduleName'</span>, <span class="param">viewModel</span> )</span></em></h3>
      <h3>Cache a viewModel/module ahead of time:</h3>
<pre><code class="javascript">// register a footwork viewModel
var Sprocket = fw.viewModel({ /* configuration object */ });
fw.viewModels.register('Sprocket', Sprocket);

// register a normal class constructor function (like in regular knockout)
var Sprocket = function() { this.isUsed = fw.observable(false); };
fw.viewModels.register('Sprocket', Sprocket);

// register an instance of an object (like in regular knockout)
fw.viewModels.register('Sprocket', {
  instance: { isUsed: false } // object representing the viewModel to be bound against the DOM
});

/**
 * A constructor function to be called when the declaration is encountered.
 * It is supplied params given at the binding (&lt;viewModel params="exampleParam: true"&gt;) and
 * the containing element of the viewModel.
 */
fw.viewModels.register('Sprocket', {
  createViewModel: function(params, info) {
    // info.element = containing &lt;viewModel&gt; element
    // params are the parameters declaratively created from the DOM (See: note below)
    return { isUsed: false }; // object representing the viewModel to be bound against the DOM
  }
});</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> Are you using a fw.viewModel() constructor and simply want to register it using the namespace name (recommended)?</p>

        <p>You can optionally just set <span class="inline-code">autoRegister: true</span> in the viewModel configuration object, then the fw.viewModel.register
          call is taken care of for you when the viewModel constructor is created.</p>

        <p>See: <a data-bind="$route" href="#configuration">viewModel configuration</a>.</p>
      </div>

      <h3><em class="func-def">fw.viewModels.registerLocation<span>( <span class="param">'moduleName'</span>, <span class="param">'path/to/module'</span> )</span></em></h3>
      <h3>Register the location of a viewModel/module so footwork can load and bind it for you when needed:</h3>
<pre><code class="javascript">// Load Sprocket from: /viewModels/parts/Sprocket.js (based on viewModel/module name, case sensitive)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts/');

// Load Sprocket from: /viewModels/parts/DifferentFileName.js (specify full file name)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts/DifferentFileName.js');

// register the location of several viewModels at once (ie: all in the same folder)
fw.viewModels.registerLocation(['Body', 'Navigation', 'Footer'], '/viewModels/pageAreas/');</code></pre>

      <h3><em class="func-def">fw.viewModels.defaultLocation<span>( <span class="param">'path/to/viewModel/folder'</span> )</span></em></h3>
      <h3>Register the default location of viewModels/modules so footwork can load and bind them for you when needed:</h3>
<pre><code class="javascript">// Load all viewModels from /myViewModels/[module-name].js (case sensitive)
fw.viewModels.defaultLocation('/myViewModels/');</code></pre>

    </div>
  </section>

  <a id="module-formats" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="module-formats">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Module Formats</h2>
    </header>
    <div class="content">
      <p>Loading your viewModel/module in so that footwork can use it is done via a script loader.</p>

      <p>Both <a href="http://requirejs.org">AMD/RequireJS</a> and <a href="http://browserify.org" target="_blank">Browserify</a> are supported. However RequireJS is
        preferred as it will enable footwork to resolve your viewModels/components (and their dependencies) automatically at runtime as needed.</p>

      <p>The following example shows the RequireJS/AMD flavored version.</p>

      <h3>viewModel and template are loaded separately:</h3>
<div class="file-location">/viewModel/sprocket.js</div>
<pre><code class="javascript">define(["footwork"],
  function(fw) {
    return fw.viewModel({
      namespace: 'sprocket'
      // ...
    });
  }
);</code></pre>

      <div class="note">
        <p><span class="label">NOTE:</span> You can return any constructor function or plain object from your viewModel modules (you don't have to return a footwork
          viewModel constructor as shown).</p>
      </div>
    </div>
  </section>

  <a id="lifecycle" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="lifecycle">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lifecycle</h2>
    </header>
    <div class="content">
      <p>Lifecycle events are automatically handled for you when using a viewModel via one of the three main methods:</p>

      <ul>
        <li>Use the <span class="inline-code">&lt;viewModel&gt; ... &lt;/viewModel&gt;</span> declarative syntax.</li>
        <li>Use the <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declarative syntax.</li>
        <li>Manually bound (<span class="inline-code">fw.applyBindings()</span>) to the DOM.</li>
      </ul>

      <p>viewModels that are attached to the DOM retrive two main lifecycle events, one just after binding to the DOM (<span class="inline-code">afterBinding()</span>)
        and one when the element (that the viewModel bound itself to) is removed from the DOM (<span class="inline-code">onDispose()</span>, called just before the
        element is removed).</p>

      <div class="note"><span class="label">NOTE:</span> Any subscriptions, namespaces, events, etc must be assigned to <span class="inline-code">this</span> if you
        want them to automatically be cleaned up for you when the viewModel is disposed.</div>

<pre><code class="javascript">var someOtherObservable = fw.observable();

var MyViewModel = fw.viewModel({
  initialize: function() {
    this.myVarSub = someOtherObservable.subscribe(function() {
      // This subscription will get cleaned up when the viewModel is disposed
    });

    this.$namespace.command.handler('doSomething', function() {
      // This command handler will get cleaned up when the viewModel is disposed
    });

    this.$someOtherNamespace = fw.namespace('SomeOtherNamespace');
    this.$someOtherNamespace.command.handler('doSomethingElse', function() {
      // This command handler will get cleaned up when the viewModel is disposed
    });

    this.someOtherThing = {
      eventHandler: this.$namespace.event.handler('someEvent', function() {
        // This will NOT get cleaned up, handler result/subscription is not attached to 'this'
      })
    };
  }
});
</code></pre>

      <p>If you do not bind a viewModel to the DOM then you will want to tell it to clean up its references when you are getting rid of it. This is done
        by calling <span class="inline-code">viewModel.dispose()</span> directly.</p>
      <h3 class="top"><em class="func-def">viewModel.dispose<span>()</span></em></h3>
      <h3>Dispose of all namespaces, handlers, and subscriptions assigned to a viewModel:</h3>
<pre><code class="javascript">var MyViewModel = fw.viewModel({ /* ... */ });
var viewModel = new MyViewModel();
// ...
viewModel.dispose(); // all namespaces, handlers, and subscriptions now cleaned up/removed
</code></pre>
    </div>
  </section>

  <a id="properties" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="properties">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Properties</h2>
    </header>
    <div class="content">
      <p>After a viewModel has been created, there are a few properties/references which are added/available to the object depending on its current state.</p>

      <h3>viewModel.$namespace <em>(available after instantiation)</em></h3>

      <p>Every instantiated viewModel will have a property called <span class="inline-code">$namespace</span>, this is the namespace channel created as a
        result of the <span class="inline-code">namespace:</span> configuration attribute given. It should be used to setup any handlers and subscriptions
        on the current namespace that a viewModel might need.</p>

<pre><code class="javascript">var Navigation = fw.viewModel({
  namespace: 'Navigation',
  initialize: function() {
    this.$namespace.event.handler('userLoggedIn', function(username) {
      console.log('Welcome', username);
    });
  }
});

var navigation = new Navigation();

var navNamespace = fw.namespace('Navigation');
navNamespace.trigger('userLoggedIn', 'Jonathan'); // console prints: Welcome Jonathan</code></pre>

      <h3>viewModel.$element <em>(available after binding)</em></h3>
      <p>After a viewModel is bound with the DOM, the element it is bound to is assigned to the <span class="inline-code">$element</span> property.</p>
<pre><code class="javascript">var Navigation = fw.viewModel({
  namespace: 'Navigation',
  initialize: function() { /* ... */ }
  afterBinding: function() {
    this.$element.className += 'isBound';
  }
});</code></pre>
    </div>
  </section>

  <a id="mixins" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="mixins">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Mixins</h1>
    </header>
    <div class="content">
      <p>Mixins are about reusing behavior, functionality, and code whenever possible. They allow you to write various behaviors/logic and then later on combine
      and compose them as you want at runtime.</p>
      <p>The mixin functionality in footwork is provided via a library called <a href="https://github.com/a2labs/riveter" target="_blank">riveter</a>.
      All <span class="inline-code">fw.viewModel()</span> based constructor functions are riveter constructor functions. Above and beyond the
      functionality outlined here, each object has various methods extended from riveter which can enable you to extend viewModels in
      various ways, I would encourage you to also <a href="https://github.com/a2labs/riveter" target="_blank">look at its documentation</a>.</p>

      <ul>
        <li><a data-bind="$route" href="#mixin-configuration">Configuration</a></li>
        <li><a data-bind="$route" href="#mixin-usage">Usage</a></li>
      </ul>

      <h3>Basic usage:</h3>
<pre><code class="javascript">var bigSprocket = { /* mixin configuration object */ };
var bikeSprocket = { /* mixin configuration object, detailed in the next section */ };

/**
 * Mixin behavior is applied to a viewModel by passing it into the
 * fw.viewModel() configuration object
 * NOTE: mixins are applied to the viewModel in the order they are given.
 */
var Sprocket = fw.viewModel({
  // ... viewModel configuration object
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },

  // mixins/behavior to include for each new 'Sprocket' viewModel
  mixins: [ bigSprocket, bikeSprocket ]
});

var mySprocket = new Sprocket({ type: 'awesome' });</code></pre>
    </div>
  </section>

  <a id="mixin-configuration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="mixin-configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>Each mixin is simply a configuration object defining certain behaviors, functionality, and logic. The behavior you define will be added to each
        viewModel instance it is configured with.</p>

      <h3>Mixin configuration object synopsis:</h3>
<pre><code class="javascript">// define 'bigSprocket' as an object to serve as the configuration container
var bigSprocket = {
  _preInit: function(param1, param2, ...) {
    /**
     * called prior to the initialize() method from the viewModel configuration being called
     * params === params passed in at creation
     * this === the viewModel
     */
  },

  mixin: {
    /**
     * these properties are added to 'this' object immediately upon creation, before
     * any methods (including _preInit) are called
     */
    function1: function() {
      // function that is extended onto the viewModel object (this) upon creation
      // this === the viewModel
    },
    function2: function() {
      // another function that is extended onto the viewModel object (this) upon creation
      // this === the viewModel
    },
    property1: 'someValue' // a raw property extended to the object
    // ...
  },

  _postInit: function() {
    /**
     * called after the initialize() method from the viewModel configuration is called
     * this === the viewModel
     */
  }
};</code></pre>

      <div class="note">
        <span class="label">NOTE:</span>
        <ul>
          <li>If you require some other type of object extension or mixin, as recommended above you should look at the
            <a href="https://github.com/a2labs/riveter" target="_blank">riveter documentation</a>.</li>

          <li>A viewModel can have as many mixins as you want, and you can re-use them across as many differing viewModels/modules as you like.</li>
        </ul>
      </div>
    </div>
  </section>

  <a id="mixin-usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="mixin-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Example mixin usage</h2>
    </header>
    <div class="content">
      <p>Each mixin behavior is added to each new instance of the viewModel that is created. This goes for ones instantiated automatically via declarative HTML, or
        directly/manually in javascript code.</p>

      <p>All mixins may be reused on both a standalone viewModel and viewModels attributed with a component.</p>
      <h3>Example usage:</h3>
<pre><code class="javascript">// define the mixin configuration object
var bigSprocket = {
  _preInit: function(param) {
    this.isAwesome = (param.type === 'awesome' ? true : false);
    // this.isBig === true
  },
  mixin: {
    isBig: true,
    fitInSmallPlace: function() {
      return false;
    }
  }
};

// create a BigSprocket contructor and include the bigSprocket mixin
var BigSprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket ]
});

var mySprocket = new BigSprocket({ type: 'awesome' });
// mySprocket.fitInSmallPlace() === false
// mySprocket.isBig === true
// mySprocket.isAwesome === true</code></pre>
    </div>
  </section>

  <a id="misc" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="misc">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Utility / Misc</h1>
    </header>
    <div class="content">
      <p>Various useful methods and utility functions for misc and debugging purposes.</p>

      <ul>
        <li><a data-bind="$route" href="#getAll">fw.viewModels.getAll()</a></li>

        <li><a data-bind="$route" href="#isRegistered">fw.viewModels.isRegistered()</a></li>

        <li><a data-bind="$route" href="#getRegistered">fw.viewModels.getRegistered()</a></li>

        <li><a data-bind="$route" href="#getResourceLocation">fw.viewModels.getResourceLocation()</a></li>

        <li><a data-bind="$route" href="#getFileName">fw.viewModels.getFileName()</a></li>

        <li><a data-bind="$route" href="#fileExtensions">fw.viewModels.fileExtensions()</a></li>
      </ul>
    </div>
  </section>

  <a id="getAll" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="getAll">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.getAll<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.viewModels.getAll<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.viewModels.getAll<span>( <span class="param">[ 'moduleName', 'moduleName2', ... ]</span> )</span></em></h3>
      <h3>Get list of currently instantiated viewModels grouped/indexed by namespace:</h3>
<pre><code class="javascript">var Bike = fw.viewModel({
  namespace: 'Bike',
  initialize: function() {
    this.isBike = true;
  }
});
var Wheel = fw.viewModel({
  namespace: 'Wheel',
  initialize: function() {
    this.isWheel = true;
  }
});

var bike = new Bike();
var wheel1 = new Wheel();
var wheel2 = new Wheel();

var viewModels = fw.viewModels.getAll();
// viewModels['Bike'][0].isBike === true
// viewModels['Wheel'].length === 2
// viewModels['Wheel'][0].isWheel === true

// Note: specifying a single namespace will result in the only those instances being returned
var viewModels = fw.viewModels.getAll('Wheel'); // get all 'Bike' instances
// viewModels[0].isWheel === true
// viewModels[1].isWheel === true

var viewModels = fw.viewModels.getAll(['Bike', 'Wheel']); // get all 'Bike' and 'Wheel' instances
// viewModels === {
//  Bike: [ { ... } ],
//  Wheel: [ { ... }, { ... } ]
// }
</code></pre>
    </div>
  </section>

  <a id="isRegistered" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="isRegistered">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.isRegistered<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Return true or false based on whether or not there is a viewModel that has been registered under 'moduleName':</h3>
<pre><code class="javascript">var Bike = fw.viewModel({
  namespace: 'Bike',
  initialize: function() {
    this.isBike = true;
  }
});

fw.viewModels.register('Bike', Bike);
// fw.viewModels.isRegistered('Bike') === true
// fw.viewModels.isRegistered('ModuleThatIsLoadedByAMD') === false</code></pre>
    </div>
  </section>

  <a id="getRegistered" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="getRegistered">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.getRegistered<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Return viewModel that has been registered under 'moduleName':</h3>
<pre><code class="javascript">// Explicit registration
var Bike = fw.viewModel({ /* ... configuration object */ });
fw.viewModels.register('Bike', Bike);
// fw.viewModels.getRegistered('Bike') === Bike;

// viewModel that registers itself
var Sprocket = fw.viewModel({
  autoRegister: true,
  // ... remainder of configuration object
});
// fw.viewModels.getRegistered('Sprocket') === Sprocket;</code></pre>
    </div>
  </section>

  <a id="getLocation" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="getLocation">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.getLocation<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Get the path footwork will attempt to load for the given 'moduleName':</h3>
<pre><code class="javascript">fw.viewModels.registerLocation('Sprocket', '/path/to/viewModel/folder');
// fw.viewModels.getLocation('Sprocket') === '/path/to/viewModel/folder'</code></pre>
    </div>
  </section>

  <a id="getFileName" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="getFileName">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.getFileName<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Get the file name that footwork will appended to the path when downloading the viewModel:</h3>
<pre><code class="javascript">var fileNameForSprocket = fw.viewModels.getFileName('sprocket'); // === sprocket.js

/**
 * If the viewModel was explicitly registered (cached), then null is returned for any
 * fileType because the file name will never be used.
 */
fw.viewModels.register('sprocket', fw.viewModel({ /* configuration object */ }) );
var fileNameForSprocket = fw.viewModels.getFileName('sprocket'); // === null
</code></pre>
    </div>
  </section>

  <a id="fileExtensions" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="fileExtensions">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.viewModels.fileExtensions<span>( <span class="param">'.ext'</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.viewModels.fileExtensions<span>( <span class="param">function(moduleName) { ... }</span> )</span></em></h3>
      <h3>Specify the extension to append to an AMD/RequireJS loaded viewModel path when it does not have an extension specified (ie: full file name not specified):</h3>
<pre><code class="javascript">// Explicitely set the extension
fw.viewModels.fileExtensions('.jscript'); // append viewModel module files with '.jscript'

// You can also specify a function() whose return value is used as the extension.
fw.viewModels.fileExtensions(function(moduleName) {
  if(moduleName === 'Sprocket') {
    return '.jscript';
  } else {
    return '.js';
  }
});</code></pre>
    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "ViewModel",
  "description": "Bindable logic and statefulness for your markup.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "configuration",
              "title": "Factory Method" },
            { "anchor": "bind-manually",
              "title": "Manual Instantiation and Binding",
              "description": "Binding a viewModel using fw.applyBindings()." },
            { "anchor": "viewModel-element",
              "title": "&lt;viewModel&gt;",
              "description": "Using a viewModel with a &lt;viewModel&gt; declarative element." },
            { "anchor": "inside-component",
              "title": "&lt;component&gt;",
              "description": "Using a viewModel with a &lt;component&gt; declarative custom element." }
          ] },
        { "title": "Lifecycle &amp; Registration",
          "anchor": "lifecycle-registration",
          "subSections": [
            { "anchor": "lifecycle",
              "title": "Lifecycle",
              "description": "Explanation of the lifecycle of a viewModel, including instantiation and disposal.",
              "subSections": [
                { "anchor": "afterBinding",
                  "title": "afterBinding()",
                  "description": "Method called after binding the viewModel to the DOM." },
                { "anchor": "onDispose",
                  "title": "onDispose()",
                  "description": "Method called after the viewModel is removed from the DOM." }
              ] },
            { "anchor": "registration",
              "title": "Registration",
              "description": "How to register a viewModel and have it loaded via AMD, asynchronously.",
              "subSections": [
                { "anchor": "module-resolution",
                  "title": "Module Resolution",
                  "description": "How footwork loads/resolves your viewModel prior to instantiation." },
                { "anchor": "module-formats",
                  "title": "Module Formats",
                  "description": "What formats a valid for a viewModel module." }
              ] }
          ] },
        { "anchor": "data-management",
          "title": "Data Management",
          "collapsable": true,
          "isCollapsed": true,
          "subSections": [
            { "anchor": "mapping-getting-setting-data",
              "title": "Mapping / Getting / Setting Data",
              "subSections": [
                { "anchor": "mapping-data",
                  "title": "Mapping Data",
                  "description": "How to map data in your viewModel, informing footwork how to transpose it to/from its RESTful endpoint." },
                { "anchor": "getting-data",
                  "title": "Getting / Reading",
                  "description": "Reading the mapped data from a viewModel." },
                { "anchor": "setting-data",
                  "title": "Setting / Writing",
                  "description": "Writing data to the viewModel via its mapped observables." }
              ] },
            { "anchor": "rest-operations",
              "title": "REST Operations",
              "keywords": [ "ajax" ],
              "subSections": [
                { "anchor": "fetching-data",
                  "title": "Fetching Model Data",
                  "description": "Fetching a models data from its REST endpoint via AJAX." },
                { "anchor": "saving-data",
                  "title": "Saving Model Data",
                  "description": "Saving a models data to its REST endpoint via AJAX." },
                { "anchor": "deleting-data",
                  "title": "Deleting / Destroying Data",
                  "description": "Deleting / destroying data from a viewModel REST endpoint." }
              ] }
          ] },
        { "anchor": "mixins",
          "title": "Mixins",
          "collapsable": true,
          "isCollapsed": true,
          "subSections": [
            { "anchor": "mixin-configuration",
              "title": "Configuration" },
            { "anchor": "mixin-usage",
              "title": "Usage" }
          ] }
      ] },
    { "subSections": [
        { "anchor": "utility-functions",
          "title": "Utility Functions",
          "collapsable": true,
          "isCollapsed": true,
          "subSections": [
            { "anchor": "viewModels-getAll",
              "title": "fw.viewModels.getAll()" },
            { "anchor": "viewModels-isRegistered",
              "title": "fw.viewModels.isRegistered()" },
            { "anchor": "viewModels-getRegistered",
              "title": "fw.viewModels.getRegistered()" },
            { "anchor": "viewModels-getLocation",
              "title": "fw.viewModels.getLocation()" },
            { "anchor": "viewModels-getFileName",
              "title": "fw.viewModels.getFileName()" },
            { "anchor": "viewModels-fileExtensions",
              "title": "fw.viewModels.fileExtensions()" }
          ]
        },
        { "anchor": "instance-properties",
          "title": "Instance Properties",
          "description": "Properties that exist on an instantiated viewModel.",
          "collapsable": true,
          "isCollapsed": true,
          "subSections": [
            { "anchor": "viewModel-namespace",
              "title": "viewModel.$namespace",
              "description": "The namespace for this viewModel used for communication with other areas of your application." },
            { "anchor": "viewModel-cid",
              "title": "viewModel.$cid",
              "description": "A unique identifier automatically assigned to every viewModel when first created." }
          ] }
      ] }
  ],
  "apiReferences": [
    {
      "label": "Constructor",
      "subCategories": [
        {
          "label": "Factory",
          "references": [
            { "anchor": "fw-viewModel",
              "title": "fw.viewModel()",
              "description": "Creates a new viewModel constructor function." }
          ]
        }
      ]
    },
    {
      "label": "Mapping Data",
      "subCategories": [
        {
          "references": [
            { "anchor": "observable-mapTo",
              "title": "observable.mapTo()",
              "description": "Tell footwork how data maps to/from the server side.",
              "keywords": [ "ajax", "REST", "async" ] }
          ]
        }
      ]
    },
    {
      "label": "Registration",
      "subCategories": [
        {
          "label": "Methods",
          "references": [
            { "anchor": "viewModels-register",
              "title": "fw.viewModels.register()",
              "description": "Register/cache a viewModel so that it is ready to be used when needed." },
            { "anchor": "viewModels-registerLocation",
              "title": "fw.viewModels.registerLocation()",
              "description": "Register the location of (or path to) a viewModel so that it can be downloaded/resolved when needed." },
            { "anchor": "viewModels-isRegistered",
              "title": "fw.viewModels.isRegistered()",
              "description": "Method used to check whether or not a viewModel has been registered or not." },
            { "anchor": "viewModels-getRegistered",
              "title": "fw.viewModels.getRegistered()",
              "description": "Return the viewModel registered under a specified name." },
            { "anchor": "viewModels-getLocation",
              "title": "fw.viewModels.getLocation()",
              "description": "Get the location footwork will attempt to download a viewModel from when it is needed." },
            { "anchor": "viewModels-getFileName",
              "title": "fw.viewModels.getFileName()",
              "description": "Get the filename footwork will use when downloading a viewModel.",
              "subDescriptions": [
                "This is appended onto the location/path when downloading."
              ] }
          ]
        }
      ]
    },
    {
      "label": "Mixins",
      "subCategories": [
        {
          "label": "Configuration",
          "references": [
            { "anchor": "afterBinding",
              "title": "afterBinding()",
              "description": "Method triggered after a viewModel has been bound to the DOM." },
            { "anchor": "onDispose",
              "title": "onDispose()",
              "description": "Method triggered after the element a viewModel is bound to is removed from the DOM.",
              "subDescriptions": [
                "This is also triggered when viewModel.dispose() is called."
              ] }
          ]
        }
      ]
    },
    {
      "label": "Lifecycle",
      "subCategories": [
        {
          "label": "Callbacks",
          "references": [
            { "anchor": "afterBinding",
              "title": "afterBinding()",
              "description": "Method triggered after a viewModel has been bound to the DOM." },
            { "anchor": "onDispose",
              "title": "onDispose()",
              "description": "Method triggered after the element a viewModel is bound to is removed from the DOM.",
              "subDescriptions": [
                "This is also triggered when viewModel.dispose() is called."
              ] }
          ]
        }
      ]
    },
    {
      "label": "Instance",
      "subCategories": [
        {
          "label": "Utility Methods",
          "references": [
            { "anchor": "viewModels-getAll",
              "title": "fw.viewModels.getAll()",
              "description": "Get all currently instantiated viewModel references.",
              "keywords": [ "instance" ] }
          ]
        },
        {
          "label": "Methods",
          "references": [
            { "anchor": "viewModel-fetch",
              "title": "viewModel.$fetch()",
              "description": "Fetch a models data from its RESTful endpoint.",
              "keywords": [ "ajax", "REST", "async", "GET" ] },
            { "anchor": "viewModel-save",
              "title": "viewModel.$save()",
              "description": "Save a models data to its RESTful endpoint.",
              "keywords": [ "ajax", "REST", "async", "POST", "PUT" ] },
            { "anchor": "viewModel-dispose",
              "title": "viewModel.dispose()",
              "description": "Dispose of a viewModel and all of its attached handlers and subscriptions.",
              "subDescriptions": [
                "This is done automatically when a bound instance is removed from the DOM."
              ] }
          ]
        },
        {
          "label": "Properties",
          "references": [
            { "anchor": "viewModel-namespace",
              "title": "viewModel.$namespace",
              "description": "The namespace for this viewModel used for communication with other areas of your application." },
            { "anchor": "viewModel-cid",
              "title": "viewModel.$cid",
              "description": "A unique identifier automatically assigned to every viewModel when first created." }
          ]
        }
      ]
    }
  ]
}
</div>

