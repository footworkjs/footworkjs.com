<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Introduction</h1>
    </header>
    <div class="content">
      <p>A Footwork <span class="inline-code">collection</span> is used to manage lists of <span class="inline-code">objects</span>. Collections are
        an extension built on top of Knockout.js
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArrays</a></span> and
        thus can be used just like they can, such as:</p>

      <ul>
        <li>Binding your UI to them.</li>
        <li>Creating a <span class="inline-code"><a target="_blank" href="http://knockoutjs.com/documentation/computedObservables.html">computed</a></span>
          value based on them (such as a filtered, or sorted version of a list).</li>
        <li>Manipulating them like normal
          <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArrays</a></span>
          using <span class="inline-code">push</span>, <span class="inline-code">pop</span>, <span class="inline-code">splice</span>, etc...</li>
      </ul>

      <p>Using the
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type,
        Footwork builds upon them to integrate various features such as:</p>

      <ul>
        <li>Searching the list to find an <span class="inline-code">object</span> or
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> (or list of them) which matches a set of attributes or id.</li>
        <li>Retrieving a list of items from the server and (if specified) instantiate each of the results using a
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>.</li>
        <li>Creating a new record of the specified <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> on the
          server and inserting it into the <span class="inline-code">collection</span> when completed.</li>
        <li>Easy methods for adding new items to or removing items from the <span class="inline-code">collection</span>.</li>
      </ul>

      <div class="note">
        <p><span class="label">Example Use-Case:</span> An app has a user profile and attached to it a list of contact phone numbers. Each phone number
          would be represented in with a <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> (which would have
          its REST endpoint used for CRUD operations, say at <span class="inline-code">/user/phone-number/123</span> for the record with id 123).</p>
        <p>There would be a <span class="inline-code">/user/phone-numbers</span> endpoint which would return a JSON list of
          phone numbers attached to my profile. This list/endpoint is what would be managed by the <span class="inline-code">collection</span> from
          within the application.</p>
        <p>If represented by a <span class="inline-code">collection</span>, you could then <span class="inline-code">fetch()</span> the
          list from the server and have the list of <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>
          instances created for you and injected into the <span class="inline-code">collection</span>. You could also <span class="inline-code">create()</span>
          a new <span class="inline-code">phone-number</span> which would be saved to the server via the
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> and its RESTful configuration.</p>
      </div>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Usage</h1>
    </header>
    <div class="content">
      <p>There are two primary ways of using <span class="inline-code">collections</span> in Footwork. They can be utilized with raw data (arrays of
        objects, i.e. a <em>plain</em> <span class="inline-code">collection</span>) or configured to use a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>. In either case you can then use any of the
        <span class="inline-code">collection</span> methods to find, retrieve, add, etc.</p>

      <p>Essentially, at the core of it you are managing a list of
        <span class="inline-code">objects</span> which may or may not have RESTful (persistent) features attached to them. With this list you can also
        bind your UI, create
        <span class="inline-code"><a target="_blank" href="http://knockoutjs.com/documentation/computedObservables.html">computed</a></span> values,
        subscribe to changes, etc (all of the same capabilities/features you have with a normal KnockoutJS
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>).</p>
    </div>
  </section>

  <a id="basic-usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="basic-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Basic Usage</h2>
    </header>
    <div class="content">
      <p>If you are using a <em>plain</em> <span class="inline-code">collection</span> (ie: one which does not require a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>) then they are initialized in exactly the same way
        a normal KnockoutJS <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        would be with the exception that you would use
        <span class="inline-code">fw.collection()</span> insted of <span class="inline-code">fw.observableArray()</span> to instantiate one.</p>

      <a id="fw-collection" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw</span>.collection<span>( [ <span class="param">item1</span>, <span class="param">item2</span>, <span class="param">...</span> ] )</span></div>
        </div>
        <div class="description">Create a <span class="inline-code">collection</span> composed of the supplied data.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">collection</span> <span class="inline-code">collection</span> Collection instance (observableArray)</span>
        </div>
      </div>
<pre><code class="javascript">var collection = fw.collection([ { name: 'James Bond' }, { name: 'Eve Moneypenny' } ]);
</code></pre>

      <h3>Creation of a simple <span class="inline-code">collection</span> instance consisting of a list of <span class="inline-code">objects</span>:</h3>
<pre><code class="javascript">var group = fw.collection([
  { name: 'John Smith', company: 'Acme Brick' },
  { name: 'Jane Doe', company: 'Acme Brick' }
]);

/**
 * group() === [
 *   { name: "John Smith", company: "Acme Brick"  },
 *   { name: "Jane Doe", company: "Acme Brick"  }
 * ]
 */

/**
 * group.findWhere({ name: "John Smith" }) === { name: "John Smith", company: "Acme Brick"  }
 */
</code></pre>
    </div>
  </section>

  <a id="factory-method" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="factory-method">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Factory Method</h2>
    </header>
    <div class="content">
      <p>If each item in your <span class="inline-code">collection</span> has a RESTful endpoint (ex: a list of notes) then you will want to create
        a <em>new</em> type of <span class="inline-code">collection</span> which is configured to handle them utilizing a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>. By doing this you can more easily fetch, save,
        retrieve, and search the data.</p>

      <p>To create and use a new type of <span class="inline-code">collection</span> we begin by creating a new constructor function, configuring it
        as desired. This is done with the factory method <span class="inline-code">fw.collection.create()</span>. The constructor function returned
        can then be used to create new instances of that type of <span class="inline-code">collection</span>.</p>

      <a id="fw-collection-create" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw</span>.collection.create<span>( <span class="param">configurationObject</span> )</span></div>
        </div>
        <div class="description">Create a new collection constructor function. This is used to create a new type of collection.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">function()</span> <span class="inline-code">Collection</span> Constructor Function</span>
        </div>
      </div>
<pre><code class="javascript">var CollectionConstructor = fw.collection.create({
  // (optional) The namespace (communications channel) the collection uses.
  namespace: 'MyCollection', // example namespace name, any alpha-numeric is valid

  // (optional) URL which will/can be used to GET the collection from the server
  url: function() {},
  url: '',

  // (optional) dataModel constructor used to create each new instance.
  dataModel: DataModelConstructor,

  /**
   * (optional) The idAttribute to use internally within each dataModel/object
   * Note: This overrides the dataModel idAttribute
   */
  idAttribute: '',

  /**
   * Flag telling footwork if it should call .dispose() when a dataModel is removed from
   * the list. Default: true.
   */
  disposeOnRemove: true
});
</code></pre>

      <p>The following example shows the creation of a <span class="inline-code">collection</span> constructor which can be used to manage
        <span class="inline-code">collections</span> consisting of
        <span class="inline-code">Person</span> <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances.</p>

      <p>A <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> would normally be used to represent items which
        also have RESTful endpoints. An example of this might be a list of contact numbers or email addresses listed on a user profile.</p>

      <h3>Creation and use of a <span class="inline-code">collection</span> constructor to create a <span class="inline-code">collection</span> (group) of people:</h3>
<pre><code class="javascript">// Create the ContactList collection constructor
var ContactList = fw.collection.create({
  namespace: "ContactList",
  url: '/list-contacts',
  // It is recommended you store the dataModel in a separate file.
  // This example shows it inline.
  dataModel: fw.dataModel({
    namespace: "Contact",
    url: '/contact',
    initialize: function(contactData) {
      this.email = fw.observable(contactData.email).mapTo('email');
      this.number = fw.observable(contactData.number).mapTo('number');
    }
  })
});

// Instantiate a new ContactList collection using the constructor
var myNumbers = ContactList([
  { number: '555-555-5555', email: 'batman@wayneindustries.com' },
  { number: '555-555-5556', email: 'robin@wayneindustries.com' }
]);

// Each entry is an instance of the Contact dataModel
// myNumbers() === [ Contact, Contact ]

/**
 * The raw mapped data can be retrieved using the helper .getData()
 * myNumbers.getData() === [
 *   { number: '555-555-5555', email: 'batman@wayneindustries.com' },
 *   { number: '555-555-5556', email: 'robin@wayneindustries.com' }
 * ]
 */
</code></pre>
    </div>
  </section>

  <a id="computed-values" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="computed-values">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Computed Values</h2>
    </header>
    <div class="content">
      <p>It is important to remember that a <span class="inline-code">collection</span> is an <em>observable</em> value. This means that just like any
        other <span class="inline-code">observable</span> we can create
        <span class="inline-code"><a target="_blank" href="http://knockoutjs.com/documentation/computedObservables.html">computed</a></span> values
        based on it.</p>

      <p>Another important note is that you can also use various <span class="inline-code">collection</span> methods (<span class="inline-code">findWhere()</span>,
        <span class="inline-code">where()</span>, and <span class="inline-code">getData()</span>) to create
        <span class="inline-code"><a target="_blank" href="http://knockoutjs.com/documentation/computedObservables.html">computed</a></span> values
        derived from them.</p>

      <h3>Create <span class="inline-code"><a target="_blank" href="http://knockoutjs.com/documentation/computedObservables.html">computed</a></span>
        values based on a <span class="inline-code">collection</span>:</h3>
<pre><code class="javascript">// Shown in a viewModel which is a more likely usage scenario
var PeopleViewModel = fw.viewModel({
  initialize: function(peopleList) {
    // The main collection of people
    this.peopleList = fw.collection(peopleList);

    /**
     * A computed based on peopleList which determines whether or not the
     * list is empty
     */
    this.hasPeopleInList = fw.computed(function() {
      return this.peopleList().length > 0;
    }, this);

    /**
     * This creates a computed value based on the peopleList
     * filtered to include only entries where()
     * company === 'OCP', sorted by the name
     */
    this.omniCorpPeople = fw.computed(function() {
      return this.peopleList
        .where({ company: 'OCP' }, { getData: true })
        .sort(function(a, b) {
          return a.name.toLowerCase() &lt; b.name.toLowerCase() ? 1 : -1;
        });
    }, this);
  }
});
</code></pre>

      <p>The above example shows the creation of a <span class="inline-code">PeopleViewModel</span> which is fed a
        <span class="inline-code">peopleList</span>. Upon initialization it then creates a <span class="inline-code">peopleList</span>
        <span class="inline-code">collection</span> using the supplied data. Two <span class="inline-code">computed</span> values are created based
        on the list, one which returns a boolean value indicating whether or not there are people in the list
        (<span class="inline-code">hasPeopleInList</span>) and <span class="inline-code">omniCorpPeople</span> which is a filtered list containing
        OCP employees sorted by their name.</p>

      <h3>Example usage of the above <span class="inline-code">computed</span> values:</h3>
<pre><code class="javascript">var peopleVM = new PeopleViewModel([
  { name: 'Peter Weller', company: 'Detroit PD' },
  { name: 'Robert Morton', company: 'OCP' },
  { name: 'Donald Johnson', company: 'OCP' }
]);
/**
 * peopleVM.omniCorpPeople() === [
 *   { name: 'Robert Morton', company: 'OCP' },
 *   { name: 'Donald Johnson', company: 'OCP' }
 * ]
 */

peopleVM.peopleList.add({ name: 'Richard Jones', company: 'OCP' });
/**
 * Since omniCorpPeople is a computed value it is automatically updated when
 * the new entry is added to peopleList. Hence we see it returned (in the sorted
 * order as defined/returned by the evaluator function) when we retrieve the
 * value again:
 *
 * peopleVM.omniCorpPeople() === [
 *   { name: 'Robert Morton', company: 'OCP' },
 *   { name: 'Richard Jones', company: 'OCP' },
 *   { name: 'Donald Johnson', company: 'OCP' }
 * ]
 */
</code></pre>
    </div>
  </section>

  <a id="ui-binding" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="ui-binding">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">UI Binding</h2>
    </header>
    <div class="content">
      <p>Since a <span class="inline-code">collection</span> is actually an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> under
        the covers, you can bind to them from your UI just as you would with an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> with
        KnockoutJS.</p>

      <p>Using the <span class="inline-code">GroupOfPeople</span> <span class="inline-code">collection</span> from above, we instantiate a list of people
      inside of the <span class="inline-code">PeopleView</span> <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span>:</p>

      <h3>Example markup used to bind with the <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> (which contains
        the collection):</h3>
<pre><code class="html">&lt;div id="people-view" data-bind="foreach: persons"&gt;
  &lt;div class="person"&gt;
    Name: &lt;span data-bind="text: name"&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

      <h3>Instantiate a new <span class="inline-code">collection</span> inside of the <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span>:</h3>
<pre><code class="javascript">var PeopleView = fw.viewModel({
  namespace: 'PeopleView',
  initialize: function() {
    this.persons = fw.collection([
      { name: 'John Smith' },
      { name: 'Jane Doe' }
    ]);
  };
});

// Bind (and render) the viewModel and its collection to the UI
fw.applyBindings(new PeopleView(), document.querySelector('#people-view'));
</code></pre>
    </div>
  </section>

  <a id="data-management" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="data-management">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Data Management</h1>
    </header>
    <div class="content">
      <p>There are various operations which you can perform on a <span class="inline-code">collection</span>.</p>

      <p>Most methods, such as <span class="inline-code">find</span>,
        <span class="inline-code">findWhere</span>, <span class="inline-code">set</span>, etc do not depend on there being a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> or endpoint
        (<span class="inline-code">url</span>) specified/configured. This means that you can use them to operate on arbitrary objects as well (ie: a
        <em>plain collection</em>).</p>

      <p>Some methods such as <span class="inline-code">fetch</span> and <span class="inline-code">create</span> require that a RESTful endpoint and/or
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> be specified when a new
        <span class="inline-code">collection</span> constructor is created.</p>
    </div>
  </section>

  <a id="loading-creating" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="loading-creating">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Loading and Creating</h2>
    </header>
    <div class="content">
      <p>The following methods are used to load data into a <span class="inline-code">collection</span> locally. You might invoke one of the following
        if you wanted to manually load some data into a <span class="inline-code">collection</span>, such as if you retrieved the models/data via some
        means other than the included <span class="inline-code">fetch</span> method.</p>

      <a id="collection-set" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>collection</span>.set<span>( [ <span class="param">item1</span>, <span class="param">item2</span>, <span class="param">...</span> ], <span class="param">options</span> )</span></div>
        </div>
        <div class="description">
          <p>Perform a <em>smart</em> update of the <span class="inline-code">collection</span> with the passed list of models.</p>
          <p>If a supplied model is not yet in the <span class="inline-code">collection</span> it will be added; if the it is already in the
            <span class="inline-code">collection</span> then its data will be merged; and if the supplied data contains
            any models that are not present in the <span class="inline-code">collection</span>, they will be removed.</p>

          <p>You can provide the following <span class="inline-code">options</span> to customize the behavior:
            <span class="inline-code">{ add: false }</span>,
            <span class="inline-code">{ remove: false }</span>, or
            <span class="inline-code">{ merge: false }</span>.</p>

          <div class="note"><span class="label">NOTE:</span> All of the <span class="inline-code">_.add</span>,
            <span class="inline-code">_.remove</span>, and <span class="inline-code">_.change</span> events are fired as appropriate.</div>
        </div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">Array</span> The affected entries/dataModels</span>
        </div>
      </div>
<pre><code class="javascript">var people = fw.collection();
people.set([
  {
    "id": 1,
    "firstName": "Bruce",
    "lastName": "Wayne"
  }, {
    "id": 2,
    "firstName": "Barbara",
    "lastName": "Gordon"
  }, {
    "id": 3,
    "firstName": "Ethan",
    "lastName": "Bennett"
  }
]);
</code></pre>

      <a id="collection-reset" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>collection</span>.reset<span>( [ <span class="param">item1</span>, <span class="param">item2</span>, <span class="param">...</span> ] )</span></div>
        </div>
        <div class="description">
          <p>Replace a collection with a new list of models (or attribute hashes). This will trigger a single <span class="inline-code">_.reset</span>
            event afterwards.</p>

          <div class="note"><span class="label">NOTE:</span> The <span class="inline-code">_.reset</span> event triggered will be passed an object
            (<span class="inline-code">{ newModels: {}, oldModels: {} }</span>) containing the relevant data at runtime.</div>
        </div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">Array</span> The entries/dataModels</span>
        </div>
      </div>
<pre><code class="javascript">var people = fw.collection();
people.reset([
  {
    "id": 1,
    "firstName": "Bruce",
    "lastName": "Wayne"
  }, {
    "id": 2,
    "firstName": "Barbara",
    "lastName": "Gordon"
  }, {
    "id": 3,
    "firstName": "Ethan",
    "lastName": "Bennett"
  }
]);
</code></pre>
    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "Collection",
  "description": "RESTful handling of dataModels with handy utilities when managing a collection of them.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "basic-usage",
              "title": "Basic Usage" },
            { "anchor": "factory-method",
              "title": "Factory Method" },
            { "anchor": "computed-values",
              "title": "Computed Values" },
            { "anchor": "ui-binding",
              "title": "UI Binding" }
          ] },
        { "anchor": "data-management",
          "title": "Data Management",
          "subSections": [
            { "anchor": "loading-creating",
              "title": "Loading and Creating" },
            { "anchor": "Fetching-finding-reading",
              "title": "Fetching, Finding/Searching, and Reading" },
            { "anchor": "basic-operations",
              "title": "Basic Operations" }
          ] }
      ] },
    { "subSections": [
        { "anchor": "utility-functions",
          "title": "Utility Functions" },
        { "anchor": "instance-properties",
          "title": "Instance Properties",
          "description": "Properties that exist on an instantiated viewModel." }
      ] }
  ],
  "apiReferences": [
    {
      "label": "",
      "subCategories": [
        {
          "label": "General",
          "references": [
            { "anchor": "fw-collection",
              "title": "fw.collection()",
              "description": "Create a collection composed of the supplied data." },
            { "anchor": "fw-collection-create",
              "title": "fw.collection.create()",
              "description": "Create a new collection constructor function. This is used to create a new type of collection." }
          ]
        },
        {
          "label": "Data Management",
          "references": [
            { "anchor": "collection-set",
              "title": "collection.set()",
              "description": "Perform a smart update of the collection with the passed list of models." },
            { "anchor": "collection-reset",
              "title": "collection.reset()",
              "description": "Replace a collection with a new list of models." }
          ]
        }
      ]
    }
  ]
}
</div>
