<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Footwork provides collections as an easy to use abstraction by which you can leverage the RESTful persistence and modeling features of a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> to create an easily managed list of them.</p>

      <p>Typically you will have a discrete <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> which will
        represent an individual item in a <span class="inline-code">collection</span> which you might want to manage in your application. An example
        of this might be a list of contact numbers, or notes attached to a record.</p>

      <p>Knockout.js provides an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        which is used to manage arbitrary lists of data while still enabling all of the awesome observable design pattern features that allows
        complex dependency chains, automatic resolution of computed values, automatic UI binding, and much more.</p>

      <p>Footwork builds upon the
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        to integrate the footwork-native <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> and provide many
        handy features for managing lists of them.</p>

      <p><em>What does this mean exactly?</em></p>

      <p>It means that you can (in addition to the features notated below) treat a footwork
        <span class="inline-code">collection</span> just as if it was an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        (because it is). You can bind your UI to it, subscribe to updates, <span class="inline-code">push()</span>,
        <span class="inline-code">pop()</span>, <span class="inline-code">reverse()</span>, <span class="inline-code">sort()</span>,
        <a href="http://knockoutjs.com/documentation/observableArrays.html#indexof" target="_blank">and much more</a>.</p>

      <p>In addition to all of the standard
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        features, footwork integrates additional functionality to help manage a list of
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances, create new ones, retrieve all data from
        them, etc.</p>

      <ul>
        <li><a data-bind="$route" href="#configuration">Configuration</a></li>
        <li><a data-bind="$route" href="#initialization">Initialization</a></li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>Each different type of <span class="inline-code">collection</span> you wish to have must have a new constructor function made for it.</p>

      <p>Collection constructor functions are created by calling the factory method <span class="inline-code">fw.collection()</span> and passing it a configuration object.</p>

      <p>The resulting constructor function can then be used to instantiate new instances of that <span class="inline-code">collection</span>.</p>

      <h3><em class="func-def">fw.collection<span>( <span class="param">configurationObject</span> )</span></em></h3>
      <h3>collection configuration object synopsis:</h3>
<pre><code class="javascript">var Collection = fw.collection({
  /**
   * The namespace (communications channel) the collection uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   */
  namespace: 'Collection', // example namespace name, any alpha-numeric is valid

  /**
   * The URL which will/can be used to GET the collection from the server
   */
  url: function() {},
  url: '',

  /**
   * A collection is a list of dataModel instances, new data will be fed into a dataModel for each record.
   * The reference provided here is the constructor used to create each new instance.
   */
  dataModel: DataModelConstructor
});</code></pre>
    </div>
  </section>

  <a id="initialization" class="section-anchor" data-bind="sectionAnchor"></a>
  <section name="initialization">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Initialization / Usage</h2>
    </header>
    <div class="content">
      <p>A collection is used just like a regular
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        would be in many respects. To instantiate one, you would use a constructor function which is generated by
        <span class="inline-code">fw.collection()</span>.</p>
<pre><code class="javascript">var Person = fw.dataModel({
  initialize: function(personData) {
    this.name = fw.observable(personData.name);
  }
});

var GroupOfPeople = fw.collection({
  url: '/people',
  dataModel: Person
});

// instantiate a new group of people (with an empty list, no people)
var group = GroupOfPeople();

/**
 * Instantiate a new group of people (with a list of people).
 * NOTE: Each item in the following array is passed to a new instantiation of the Person dataModel
 */
var group = GroupOfPeople([
  { name: 'John Smith' },
  { name: 'Jane Doe' },
]);

var people = group();
var person1 = people[0];
var person2 = people[1];
// person1.name() === 'John Smith'</code></pre>

      <p>In a more practical example you would likely use a <span class="inline-code">collection</span> inside of a
        <span class="inline-code">viewModel</span>, <span class="inline-code">dataModel</span>, or even <span class="inline-code">router</span>
        instance. Basically anything you might want an array/collection of dataModels (typically when you are binding something to UI - just like you
        would an <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        with Knockout.js).</p>
<pre><code class="javascript">var peopleDisplay = fw.viewModel({
  initialize: function() {
    this.people = GroupOfPeople([
      { name: 'John Smith' },
      { name: 'Jane Doe' },
    ]);
  }
});

// And then bind that viewModel to the UI somehow
</code></pre>

    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "Collection",
  "description": "RESTful handling of dataModels with handy utilities when managing a collection of them.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "configuration",
          "title": "Configuration" },
        { "anchor": "initialization",
          "title": "Initialization / Usage" }
      ] }
  ]
}
</div>
