<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>A Footwork <span class="inline-code">collection</span> is an abstraction used to manage/persist lists of
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances/records (a collection of things with
        REST endpoints).</p>

      <div class="note">
        <p><span class="label">NOTE:</span> If the collection of data you wish to represent does not have a RESTful endpoint, or is
        just some arbitrary list of data (like an array of strings or dates, or plain objects) then you probably want to use a Knockout
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        instead (which are usable/available from within footwork via <span class="inline-code">fw.observableArray()</span>).</p>

        <p>A <span class="inline-code">collection</span> (from a footwork.js perspective) is specifically aimed at helping you manage a list of
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances.</p>

        <div class="box">
          <div class="title">Example Use-Case:</div>
          <div class="content">
            <p>An app has a user profile and attached to it a list of contact phone numbers. Each phone number would be represented
              in via a <span class="inline-code">dataModel</span> (which would have its REST endpoint used for CRUD operations, say at
              <span class="inline-code">/user/phone-number/123</span> for the record with id 123).</p>
            <p>There would be a (for example) <span class="inline-code">/user/phone-numbers</span> endpoint which would return a JSON list of
              phone numbers attached to my profile. This list/endpoint is what would be managed by the <span class="inline-code">collection</span> from
              within the application.</p>
            <p>If represented by a <span class="inline-code">collection</span>, you could then (as an example) <span class="inline-code">$fetch</span> the
              list from the server and have the list of <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span>
              instances created for me and injected into the <span class="inline-code">collection</span>.</p>
          </div>
        </div>
      </div>

      <p>Knockout.js provides (and by proxy, Footwork also has) an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        which is used to manage arbitrary lists of data while enabling all of the awesome observable design pattern features that allows
        complex dependency chains, automatic resolution of computed values, UI binding, and much more.</p>

      <p>Footwork builds upon the
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        to integrate a <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> and provide many handy features for
        managing lists of them.</p>

      <p><em>What does this mean exactly?</em></p>

      <p>It means that you can treat a Footwork <span class="inline-code">collection</span> just as if it was an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        (because thats what it is). You can bind your UI to it, subscribe to updates, make computed (dependent observables) based on them,
        <span class="inline-code">push()</span>, <span class="inline-code">pop()</span>, <span class="inline-code">reverse()</span>,
        <span class="inline-code">sort()</span>,
        <a href="http://knockoutjs.com/documentation/observableArrays.html#indexof" target="_blank">and much more</a>.</p>

      <p>Additionally to all of the standard
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        features, Footwork integrates functionality to help manage a list of them on a server/REST endpoint (via methods <span class="inline-code">fetch</span>,
        <span class="inline-code">get</span>, <span class="inline-code">set</span>, etc).</p>

      <p>As an example, this means you could bind your UI to a <span class="inline-code">collection</span> which you then call
        <span class="inline-code">collection.fetch()</span> on, resulting in the list of items being fetched, automatically initialized, and rendered for you.</p>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Usage</h1>
    </header>
    <div class="content">
      <p>At its core a <span class="inline-code">collection</span> is a Knockout
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>.
        Considering this fact, you can use them in exactly the same way.</p>

      <p>Common uses might include binding to a list of them in your markup to create an automatically populated and managed list of contacts. Or
        another might be a list of todo items one might have to do. It can be anything...it's really just a way to manage a list of
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances (and a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> can essentially contain anything).</p>
    </div>
  </section>

  <a id="factory-method" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="factory-method">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Factory Method</h2>
    </header>
    <div class="content">
      <p>Each different type of <span class="inline-code">collection</span> you wish to have must have a new constructor function made for it.</p>

      <p>Collection constructor functions are created by calling the factory method <span class="inline-code">fw.collection()</span> and passing it a configuration object.</p>

      <p>The resulting constructor function can then be used to instantiate new instances of that <span class="inline-code">collection</span>.</p>

      <a id="fw-collection" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw</span>.collection<span>( <span class="param">configurationObject</span> )</span></div>
        </div>
        <div class="description">Create a <span class="inline-code">collection</span> constructor function.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">function()</span> <span class="inline-code">Collection</span> Constructor Function</span>
        </div>
      </div>
<pre><code class="javascript">var Collection = fw.collection({
  // The namespace (communications channel) the collection uses.
  namespace: 'MyCollection', // example namespace name, any alpha-numeric is valid

  // (optional) URL which will/can be used to GET the collection from the server
  url: function() {},
  url: '',

  /**
   * A collection is a list of dataModel instances, new data will be fed into a dataModel for each record.
   * The reference provided here is the constructor used to create each new instance.
   */
  dataModel: DataModelConstructor
});</code></pre>
    </div>
  </section>

  <a id="initialization-and-basic" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="initialization-and-basic">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Initialization and Basic Usage</h2>
    </header>
    <div class="content">
      <p>The following example shows the creation of a simple <span class="inline-code">collection</span> consisting of <span class="inline-code">Person</span>
        <span class="inline-code">dataModel</span> instances.</p>
      <p>Using an instance of that <span class="inline-code">collection</span> we then call <span class="inline-code">get()</span> to retrieve
        the pure javascript object (POJO) output of the <span class="inline-code">collection</span> which is computed from the
        <span class="inline-code">dataModel</span> instances in the <span class="inline-code">collection</span> at call-time.</p>

      <h3>Creation of constructor:</h3>
<pre><code class="javascript">var GroupOfPeople = fw.collection({
  namespace: "GroupOfPeople",
  // It is recommended you store the dataModel in a separate file.
  // This example shows it inline.
  dataModel: fw.dataModel({
    namespace: "Person",
    initialize: function(personData) {
      this.name = fw.observable(personData.name).mapTo('name');
    }
  })
});</code></pre>

      <h3>Instantiate a new <span class="inline-code">collection</span> and retrieve its data:</h3>
<pre><code class="javascript">var group = GroupOfPeople([
  { name: 'John Smith' },
  { name: 'Jane Doe' },
]);

// get() the javascript object (hash-map) output of the data
var people = group.get();

/**
 * people === [
 *   { "name": "John Smith" },
 *   { "name": "Jane Doe" }
 * ]
 */
</code></pre>
    </div>
  </section>

  <a id="ui-binding" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="ui-binding">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">UI Binding</h2>
    </header>
    <div class="content">
      <p>Since a <span class="inline-code">collection</span> is an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> under
        the covers you can bind to them from your UI just as you would with Knockoutjs.</p>


    </div>
  </section>
</article>

<div id="metaData">

{
  "title": "Collection",
  "description": "RESTful handling of dataModels with handy utilities when managing a collection of them.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "factory-method",
              "title": "Factory Method" },
            { "anchor": "initialization-and-basic",
              "title": "Initialization and Basic Usage" },
            { "anchor": "ui-binding",
              "title": "UI Binding" },
            { "anchor": "adding-removing",
              "title": "Adding / Removing items" }
          ] }
      ] },
    { "subSections": [
        { "anchor": "utility-functions",
          "title": "Utility Functions" },
        { "anchor": "instance-properties",
          "title": "Instance Properties",
          "description": "Properties that exist on an instantiated viewModel." }
      ] }
  ],
  "apiReferences": [
    {
      "label": "",
      "subCategories": [
        {
          "label": "General",
          "references": [
            { "anchor": "fw-collection",
              "title": "fw.collection()",
              "description": "Creates a new collection constructor function." }
          ]
        }
      ]
    }
  ]
}
</div>
