<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">

      <div class="note">
        <p><span class="label">NOTE:</span> If the list of items (collection) you wish to represent does not have a RESTful endpoint, or is just some
        arbitrary list of data (like an array of strings or dates) then you probably are looking to use the Knockout
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        instead (which are usable/available from within footwork via <span class="inline-code">fw.observableArray()</span>).</p>

        <p>A <span class="inline-code">collection</span> (in footwork terms) is specifically aimed at helping you manage a list of
          <span class="inline-code">dataModel</span> instances.</p>

        <div class="box">
          <div class="title">Example Use-Case:</div>
          <div class="content">
            <p>I have a user profile and attached to it I have a list of contact phone numbers. Each phone number would be represented
              in my application via a <span class="inline-code">dataModel</span> (which would have its REST endpoint used for CRUD operations, say at
              <span class="inline-code">/user/phone-number/123</span> for the record with id 123).</p>
            <p>I would then also have a (for example) <span class="inline-code">/user/phone-numbers</span> endpoint which would return a JSON list of
              phone numbers attached to my profile. This list/endpoint is what would be managed by the <span class="inline-code">collection</span> from
              within the application.</p>
            <p>If represented by a <span class="inline-code">collection</span>, I could then (as an example) <span class="inline-code">$fetch</span> the
              list from the server and have my list of <span class="inline-code">dataModel</span> instances created for me and injected into the
              <span class="inline-code">collection</span>.</p>
          </div>
        </div>
      </div>

      <p>Footwork provides collections as an easy to use abstraction which you can leverage to manage/persist lists of
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances/records (a collection of things with
        REST endpoints).</p>

      <p>Typically you will have a discrete <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> which will
        represent an individual item in a <span class="inline-code">collection</span> which you might want to manage in your application. An example
        of this might be a list of contact numbers, or notes attached to an account.</p>

      <p>Knockout.js provides an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        which is used to manage arbitrary lists of data while enabling all of the awesome observable design pattern features that allows
        complex dependency chains, automatic resolution of computed values, automatic UI binding, and much more.</p>

      <p>Footwork builds upon the
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        to integrate the footwork-native <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> and provide many
        handy features for managing lists of them.</p>

      <p><em>What does this mean exactly?</em></p>

      <p>It means that you can treat a footwork <span class="inline-code">collection</span> just as if it was an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        (because it is). You can bind your UI to it, subscribe to updates, make computed (dependent observables) based on them, <span class="inline-code">push()</span>,
        <span class="inline-code">pop()</span>, <span class="inline-code">reverse()</span>, <span class="inline-code">sort()</span>,
        <a href="http://knockoutjs.com/documentation/observableArrays.html#indexof" target="_blank">and much more</a>. Additionally to all of the standard
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        features, footwork integrates functionality to help manage a list of them on a server/REST endpoint (<span class="inline-code">fetch</span>,
        <span class="inline-code">get</span>, <span class="inline-code">set</span>, etc).</p>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Usage</h1>
    </header>
    <div class="content">
      <p>At its core a <span class="inline-code">collection</span> is a Knockout
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>.
        Considering this fact, you can use them in exactly the same way.</p>

      <p>Common uses might include binding to a list of them in your markup to create an automatically populated and managed list of contacts. Or
        another might be a list of todo items one might have to do. It can be anything...it's really just a way to manage a list of
        <span class="inline-code">dataModel</span> instances (and a <span class="inline-code">dataModel</span> can essentially contain anything).</p>
    </div>
  </section>

  <a id="factory-method" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="factory-method">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Factory Method</h2>
    </header>
    <div class="content">
      <p>Each different type of <span class="inline-code">collection</span> you wish to have must have a new constructor function made for it.</p>

      <p>Collection constructor functions are created by calling the factory method <span class="inline-code">fw.collection()</span> and passing it a configuration object.</p>

      <p>The resulting constructor function can then be used to instantiate new instances of that <span class="inline-code">collection</span>.</p>

      <a id="fw-collection" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def">fw.collection<span>( <span class="param">configurationObject</span> )</span></div>
        </div>
        <div class="description">Create a <span class="inline-code">collection</span> constructor function.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">function()</span> <span class="inline-code">Collection</span> Constructor Function</span>
        </div>
      </div>
<pre><code class="javascript">var Collection = fw.collection({
  /**
   * The namespace (communications channel) the collection uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   */
  namespace: 'Collection', // example namespace name, any alpha-numeric is valid

  /**
   * The URL which will/can be used to GET the collection from the server
   */
  url: function() {},
  url: '',

  /**
   * A collection is a list of dataModel instances, new data will be fed into a dataModel for each record.
   * The reference provided here is the constructor used to create each new instance.
   */
  dataModel: DataModelConstructor
});</code></pre>

      <h3>Basic usage:</h3>
<pre><code class="javascript">/**
 * Create the collection constructor, giving it the REST endpoint and dataModel
 * to use (which can also have its own REST endpoint)
 */
var GroupOfPeople = fw.collection({
  namespace: "GroupOfPeople",
  url: '/people',
  dataModel: fw.dataModel({
    namespace: "Person",
    url: '/person',
    initialize: function(personData) {
      this.name = fw.observable(personData.name);
    }
  })
});

// Instantiate a new group of people (with an empty list, no people)
var group1 = GroupOfPeople();

// Grab the list of people from its endpoint
group1.fetch().done(function() {
  var people = group1();
  // people[0].name() === 'John Smith'
});

/**
 * Instantiate a new group of people (this time with a list of people).
 * NOTE: Each item in the following array is passed to a new instantiation of the Person dataModel
 */
var group2 = GroupOfPeople([
  { name: 'John Smith' },
  { name: 'Jane Doe' },
]);

var people = group2();
var person1 = people[0];
var person2 = people[1];
// person1.name() === 'John Smith'</code></pre>
    </div>
  </section>

  <a id="ui-binding" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="ui-binding">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">UI Binding</h2>
    </header>
    <div class="content">
      <p>Since a <span class="inline-code">collection</span> is an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> under
        the covers you can bind to them from your UI just as you would with knockoutjs.</p>

<pre><code class="javascript">var peopleDisplay = fw.viewModel({
  initialize: function() {
    this.people = GroupOfPeople([
      { name: 'John Smith' },
      { name: 'Jane Doe' },
    ]);
  }
});

// And then bind that viewModel to the UI somehow
</code></pre>

    </div>
  </section>
</article>

<div id="metaData">

{
  "title": "Collection",
  "description": "RESTful handling of dataModels with handy utilities when managing a collection of them.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "factory-method",
              "title": "Factory Method" },
            { "anchor": "ui-binding",
              "title": "UI Binding" },
            { "anchor": "adding-removing",
              "title": "Adding / Removing items" }
          ] }
      ] },
    { "subSections": [
        { "anchor": "utility-functions",
          "title": "Utility Functions" },
        { "anchor": "instance-properties",
          "title": "Instance Properties",
          "description": "Properties that exist on an instantiated viewModel." }
      ] }
  ],
  "apiReferences": [
    {
      "label": "",
      "subCategories": [
        {
          "label": "General",
          "references": [
            { "anchor": "fw-collection",
              "title": "fw.collection()",
              "description": "Creates a new collection constructor function." }
          ]
        }
      ]
    }
  ]
}
</div>
