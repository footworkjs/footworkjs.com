<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Footwork provides collections as an easy to use abstraction by which you can leverage the RESTful persistence and modeling features of a
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> to create an easily managed list of them.</p>

      <p>Typically you will have a discrete <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> which will
        represent an individual item in a <span class="inline-code">collection</span> which you might want to manage in your application. An example
        of this might be a list of contact numbers, or notes attached to a record.</p>

      <p>Knockout.js provides an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        which is used to manage arbitrary lists of data while still enabling all of the awesome observable design pattern features that allows
        complex dependency chains, automatic resolution of computed values, automatic UI binding, and much more.</p>

      <p>Footwork builds upon the
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> type
        to integrate the footwork-native <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> and provide many
        handy features for managing lists of them.</p>

      <p><em>What does this mean exactly?</em></p>

      <p>It means that you can (in addition to the features notated below) treat a footwork
        <span class="inline-code">collection</span> just as if it was an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        (because it is). You can bind your UI to it, subscribe to updates, <span class="inline-code">push()</span>,
        <span class="inline-code">pop()</span>, <span class="inline-code">reverse()</span>, <span class="inline-code">sort()</span>,
        <a href="http://knockoutjs.com/documentation/observableArrays.html#indexof" target="_blank">and much more</a>.</p>

      <p>In addition to all of the standard
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>
        features, footwork integrates additional functionality to help manage a list of
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> instances, create new ones, retrieve all data from
        them, etc.</p>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Usage</h1>
    </header>
    <div class="content">
      <p>At its core a <span class="inline-code">collection</span> is a Knockout
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span>.
        Considering this fact, you can use them in exactly the same way.</p>

      <p>Common uses might include binding to a list of them in your markup to create an automatically populated and managed list of contacts. Or
        another might be a list of todo items one might have to do. It can be anything...it's really just a way to manage a list of
        <span class="inline-code">dataModel</span> instances (and a <span class="inline-code">dataModel</span> can essentially contain anything).</p>
    </div>
  </section>

  <a id="factory-method" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="factory-method">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Factory Method</h2>
    </header>
    <div class="content">
      <p>Each different type of <span class="inline-code">collection</span> you wish to have must have a new constructor function made for it.</p>

      <p>Collection constructor functions are created by calling the factory method <span class="inline-code">fw.collection()</span> and passing it a configuration object.</p>

      <p>The resulting constructor function can then be used to instantiate new instances of that <span class="inline-code">collection</span>.</p>

      <a id="fw-collection" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def">fw.collection<span>( <span class="param">configurationObject</span> )</span></div>
        </div>
        <div class="description">Create a <span class="inline-code">collection</span> constructor function.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">function()</span> <span class="inline-code">Collection</span> Constructor Function</span>
        </div>
      </div>
<pre><code class="javascript">var Collection = fw.collection({
  /**
   * The namespace (communications channel) the collection uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   */
  namespace: 'Collection', // example namespace name, any alpha-numeric is valid

  /**
   * The URL which will/can be used to GET the collection from the server
   */
  url: function() {},
  url: '',

  /**
   * A collection is a list of dataModel instances, new data will be fed into a dataModel for each record.
   * The reference provided here is the constructor used to create each new instance.
   */
  dataModel: DataModelConstructor
});</code></pre>

      <h3>Very basic dataModel used in the collection examples below:</h3>
<pre><code class="javascript">var Person = fw.dataModel({
  initialize: function(personData) {
    this.name = fw.observable(personData.name);
  }
});</code></pre>

      <h3>Creation of constructor function:</h3>
<pre><code class="javascript">// Create the dataModel we will use in our collection
// Create the collection constructor, giving it the REST endpoint and dataModel to use
var GroupOfPeople = fw.collection({
  url: '/people',
  dataModel: Person
});

// instantiate a new group of people (with an empty list, no people)
var group = GroupOfPeople();

/**
 * Instantiate a new group of people (this time with a list of people).
 * NOTE: Each item in the following array is passed to a new instantiation of the Person dataModel
 */
var group = GroupOfPeople([
  { name: 'John Smith' },
  { name: 'Jane Doe' },
]);

var people = group();
var person1 = people[0];
var person2 = people[1];
// person1.name() === 'John Smith'</code></pre>
    </div>
  </section>

  <a id="ui-binding" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="ui-binding">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">UI Binding</h2>
    </header>
    <div class="content">
      <p>Since a <span class="inline-code">collection</span> is an
        <span class="inline-code"><a href="http://knockoutjs.com/documentation/observableArrays.html" target="_blank">observableArray</a></span> under
        the covers you can bind to them from your UI just as you would with knockoutjs.</p>

<pre><code class="javascript">var peopleDisplay = fw.viewModel({
  initialize: function() {
    this.people = GroupOfPeople([
      { name: 'John Smith' },
      { name: 'Jane Doe' },
    ]);
  }
});

// And then bind that viewModel to the UI somehow
</code></pre>

    </div>
  </section>
</article>

<div id="metaData">

{
  "title": "Collection",
  "description": "RESTful handling of dataModels with handy utilities when managing a collection of them.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "factory-method",
              "title": "Factory Method" },
            { "anchor": "ui-binding",
              "title": "UI Binding" },
            { "anchor": "adding-removing",
              "title": "Adding / Removing items" }
          ] }
      ] },
    { "subSections": [
        { "anchor": "utility-functions",
          "title": "Utility Functions" },
        { "anchor": "instance-properties",
          "title": "Instance Properties",
          "description": "Properties that exist on an instantiated viewModel." }
      ] }
  ],
  "apiReferences": [
    {
      "label": "",
      "subCategories": [
        {
          "label": "General",
          "references": [
            { "anchor": "fw-collection",
              "title": "fw.collection()",
              "description": "Creates a new collection constructor function." }
          ]
        }
      ]
    }
  ]
}
</div>
