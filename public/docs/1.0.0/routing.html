<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Routing in a web application is about managing state. Modern single-page web applications make use of the HTML5 <span class="inline-code">history</span>
        API in order to retain normal browser navigation while not forcing a complete refresh of the page on every state/url change. Footwork includes a router which
        provides this functionality.</p>

      <p>The router included with footwork has a several key features:</p>

      <ul>
        <li>Unlimited nesting of routers (relative and non-relative).</li>
        <li>Unlimited number of view outlets per router.</li>
        <li>Context based sub-routing.</li>
        <li>Context based outlets.</li>
        <li>Parameterized routes (with optional or required parameters).</li>
        <li>Filtered/predicated routes.</li>
        <li>Integration with <a href="https://github.com/browserstate/history.js/" target="_blank">history.js</a> for cross-browser history API as well as hash-based
          routing support.</li>
      </ul>

      <p>In essence the router combines several design patterns (MVC + MVVM + Observable), context-based subrouting, and context-based outlets to provide a novel and extremely
        powerful routing solution.</p>

      <h3>Routers have four principle components which make them useful:</h3>

      <ul>
        <li><a data-bind="$route" href="#configuration">configuration object</a>: A router configuration used to generate the constructor function. It defines
          the router, its routes, controllers, and their actions.</li>

        <li><a data-bind="$route" href="#usage">&lt;router&gt; declaration</a>: A <span class="inline-code">&lt;router&gt;</span> declaration tells footwork what
          portion of the DOM a <span class="inline-code">router</span> is responsible for.</li>

        <li><a data-bind="$route" href="#outlets">outlets</a>: Any number of <span class="inline-code">&lt;outlet&gt;&lt;/outlet&gt;</span> declarations in your
          HTML which are the output points your router controls.</li>

        <li><a data-bind="$route" href="#route-binding">route bindings</a>: Special bindings for links (and other tags) which will initiate new states in your
          <span class="inline-code">router</span>.</li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Configuration</h1>
    </header>
    <div class="content">
      <p>Routers are used much like <span class="inline-code">viewModels</span> are. You create them by binding them to the DOM in the same way, but instead using the constructor
        functions created by <span class="inline-code">fw.router()</span>.</p>

      <h3><em class="func-def">fw.router<span>( <span class="param">configurationObject</span> )</span></em></h3>
<pre><code class="javascript">var RouterConstructor = fw.router({
  // by default the namespace is based off of the viewModel it is paired with
  namespace: 'namespaceName', // (this is not usually needed)

  /**
   * If true, footwork will register the router under its namespace name. This means
   * that when this fw.router() call is made it will automatically call
   * fw.routers.register('RouterName', ThisRouterConstructor)
   * This is one (handy) way of telling footwork how to find your router when it needs it.
   */
  autoRegister: false, // default === false

  /**
   * If true, the namespace will have an auto-incremented 0-based index number appended for
   * each new router (ie: new instances will not share the same namespace).
   */
  autoIncrement: false, // default === false

  // function which will run just after the router is initialized and bound onto the DOM
  initialize: function(param1, param2, param3, ...) {
    // this === the router instance
    // Note that you can create observables to bind against just like a viewModel/etc
    this.param1 = fw.observable(param1);
  },

  // Behavioral mixins to include with each new router created
  mixins: [
    // See: 'Mixins' section on this page
  ],

  // Function called just after binding to the DOM
  afterBinding: function(containingElement) {
    // this === the router instance
  },

  // Function called just before the html this router is bound to is removed from the DOM
  onDispose: function(containingElement) {
    // this === the router instance
  },

  // routes list definition
  routes: [],

  // unknown route (triggered if none of the routes[] match from above)
  unknownRoute: {},

  // if true all routes defined for the router will be relative to its parent router (if any)
  isRelative: true, // default is true

  // if true the router will activate as soon as it is bound to the DOM
  activate: true, // default is true

  // tell the router to exclude the beginning portion of a route
  baseRoute: '' // default is null
});</code></pre>

      <p>The <span class="inline-code">routes: []</span> and <span class="inline-code">unknownRoute: {}</span> definitions both have the same syntax. The only difference between
        these two is that <span class="inline-code">routes: []</span> is an array of route definitions, and <span class="inline-code">unknownRoute: {}</span> is a single route
        definition. These define the routes your application (on this router) has available to it.</p>

      <ul>
        <li><a data-bind="$route" href="#routes">Routes List</a></li>
        <li><a data-bind="$route" href="#route">Route Definition</a></li>
        <li><a data-bind="$route" href="#router-properties">Router Properties</a></li>
      </ul>
    </div>
  </section>

  <a id="routes" class="section-anchor"></a>
  <section name="routes">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Routes List</h2>
    </header>
    <div class="content">
      <p>When a new state/url is requested each router will iteratively search its <span class="inline-code">routes: []</span> list from the top down for the first matching route.
        If more than one route matches for a given url/state then only the first one found found will be used.</p>

      <h3>Example <span class="inline-code">routes: []</span> list definition:</h3>
<pre><code class="javascript">// ...
routes: [
  { // default route: '/'
    route: '/',
    // ...
  },
  { // route: /store
    route: '/store',
    // ...
  }
],
unknownRoute: { /* ... */ }
// ...
</code></pre>

      <div class="note"><span class="label">NOTE:</span> The <span class="inline-code">unknownRoute:</span> definition has no <span class="inline-code">route:</span> parameter (it
        is ignored if included). This route is triggered when no matching route is found in the <span class="inline-code">routes:</span> list. It is otherwise configured just like
        the other route definitions.</div>
    </div>
  </section>

  <a id="route" class="section-anchor"></a>
  <section name="route">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Route Definition</h2>
    </header>
    <div class="content">
      <p>A route definition is simply an object which describes a route. Footwork will match the browser path up
      against the <span class="inline-code">route:</span> parameter and use the other options to trigger and setup the state of your application.</p>

      <p>A route definition has four possible parameters:</p>
      <ul>
        <li><span class="inline-code">route:</span> - A specially structured string which is used to match against a given URL (and optionally provide for named parameters).</li>

        <li><span class="inline-code">controller:</span> - Callback function used when a route is chosen, this is where <span class="inline-code">outlets</span> get changed and the
          state of your application is altered. Any parameters defined by the <span class="inline-code">route:</span> will be passed in as individual arguments.</li>

        <li><span class="inline-code">title:</span> - (<em>optional</em>) A string or callback function used to set the title of the page when the route is chosen. Any parameters
          defined by the <span class="inline-code">route:</span> will be passed in.</li>

        <li><span class="inline-code">filter:</span> - (<em>optional</em>) A predicate function used to tell footwork if it should consider a route. Any parameters defined by the
          <span class="inline-code">route:</span> will be passed in.</li>
      </ul>

      <h3><span class="inline-code">route:</span> example definitions with and without parameters specified:</h3>
      <h3><span class="inline-code">controller:</span> example definitions with and without parameters passed in:</h3>
<pre><code class="javascript">// ...
routes: [
  { // static route (no parameters): /about-us
    route: '/about-us',
    controller: function() { /* ... */ }
  },
  { // route with required parameter isbn
    route: '/book/:isbn',
    controller: function(isbn) {
      console.log('Book ISBN', isbn);
    }
  },
  { // route with optional parameter storeNum
    route: '/info(/:storeNum)',
    controller: function(storeNum) {
      // storeNum is undefined if no storeNum is provided in the route
      console.log('Store Number', storeNum);
    }
  }
],
// ...
</code></pre>

      <h3><span class="inline-code">title:</span> example definitions as a string and callback:</h3>
      <p>This (optional) parameter defines what the title of the page will be set to when routing to this route. The route params (if any) as described by the route: string will be
        passed in.</p>
<pre><code class="javascript">// ...
routes: [
  { // 'string' title
    title: 'Store Page',
    route: '/store',
    controller: function() { /* ... */ }
  },
  { // callback-based title
    title: function(isbn) {
      return 'Book ' + isbn;
    },
    route: '/book/:isbn',
    controller: function(params) { /* ... */ }
  }
],
// ...
</code></pre>

      <h3><span class="inline-code">filter:</span> example definition:</h3>
      <p>If this (optional) callback returns a 'falsey' value, the
      router will ignore the route even if the path matches. Conversely if the callback returns a
      'truthy' value the router will consider it on a first-found first-routed basis as normal.
      The route params (if any) as described by the <span class="inline-code">route:</span> string will be passed in.</p>
<pre><code class="javascript">// ...
routes: [
  { // only routed to when isbn === '12345'
    route: '/book/:isbn',
    title: 'Special Book Page',
    controller: function(isbn) {
      console.log('Special Book ISBN', isbn);
    },
    filter: function(isbn) {
      if(isbn === '12345') {
        return true; // this route used only if isbn === '12345'
      }
      return false;
    }
  },
  { // normal book/:isbn route that is used when isbn !== '12345'
    route: '/book/:isbn',
    title: 'Home Page',
    controller: function(isbn) {
      console.log('Book ISBN', isbn);
    }
  }
],
// ...
</code></pre>

      <div class="note"><span class="label">NOTE:</span> Remember that you can always <a data-bind="$route: docLink('namespacing#request')">
        <span class="inline-code">request</span></a>
        data, or use <a data-bind="$route: docLink('broadcastable-receivable')"><span class="inline-code">receivables</span>/<span class="inline-code">broadcastables</span></a>/etc
        inside of your filter functions too.</div>
    </div>
  </section>

  <a id="router-properties" class="section-anchor"></a>
  <section name="router-properties">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">(instantiated) Router Properties</h2>
    </header>
    <div class="content">
      <p>After a router has been instantiated (it is available immediately after a viewModel instance is created, at <span class="inline-code">viewModel.$router</span>) it has a
        handful of helpful properties and methods.</p>

      <p>They are as follows:</p>

      <ul>
        <li><span class="inline-code">router.setState()</span> - Set the state/url for this router, triggering any routes/controllers.</li>
        <li><span class="inline-code">router.addRoutes()</span> - Add route(s) programmatically.</li>
        <li><span class="inline-code">router.setRoutes()</span> - (clear out and) Set the routes for a router programmatically.</li>
        <li><span class="inline-code">router.currentRoute()</span> - Get the current route details.</li>
        <li><span class="inline-code">router.outlets{}</span> - List/Collection of registered outlets.</li>
      </ul>

      <h3><em class="func-def">router.setState<span>( <span class="param">'/new/state'</span> )</span></em></h3>
      <h3>Set the state/url for this router, triggering any routes/controllers:</h3>
<pre><code class="javascript">fw.router({
  namespace: 'MainRouter',
  initialize: function() {
    // trigger the route that matches for '/about'
    this.setState('/about');
  }
  routes: [
    {
      title: 'Index Page',
      route: '/',
      controller: function() { /* ... */ }
    },
    {
      title: 'About Page',
      route: '/about',
      controller: function(params) { /* ... */ }
    }
  ]
});</code></pre>

      <h3><em class="func-def">router.addRoutes<span>( <span class="param">[ /* routes */ ]</span> )</span></em></h3>
      <h3>Add route(s) programmatically:</h3>
<pre><code class="javascript">fw.router({
  namespace: 'MainRouter',
  initialize: function() {
    this.addRoutes([
      {
        title: 'Index Page',
        route: '/',
        controller: function() { /* ... */ }
      },
      {
        title: 'Book Page',
        route: '/book/:isbn',
        controller: function(params) { /* ... */ }
      }
    ]);
  }
});</code></pre>

      <h3><em class="func-def">router.setRoutes<span>( <span class="param">[ /* routes */ ]</span> )</span></em></h3>
      <h3>(clear out and) Set the routes for a router programmatically:</h3>
<pre><code class="javascript">fw.router({
  namespace: 'MainRouter',
  initialize: function() {
    this.setRoutes([
      {
        title: 'Index Page',
        route: '/',
        controller: function() { /* ... */ }
      },
      {
        title: 'Book Page',
        route: '/book/:isbn',
        controller: function(params) { /* ... */ }
      }
    ]);
  }
});</code></pre>

      <h3><em class="func-def">router.currentRoute<span>()</span></em></h3>
      <h3>Get the current route details:</h3>
<pre><code class="javascript">// Browser currently pointed to 'http://application.com/book/22'
fw.router({
  namespace: 'MainRouter',
  routes: [
    {
      title: 'Index Page',
      route: '/',
      controller: function() { /* ... */ }
    },
    {
      title: 'Book Page',
      route: '/book/:isbn',
      controller: function(params) { /* ... */ }
    }
  ],
  initialize: function() {
    var currentRoute = this.currentRoute();
    // currentRoute.segment === '/book/22' (this specific route segment/path)
    // currentRoute.url === '/book/22' (full url, includes parent and children segments)
    // currentRoute.namedParams.isbn === '22'
    // currentRoute.title === 'Book Page'
  }
});</code></pre>

      <h3><span class="inline-code">router.outlets{}</span> - List/Collection of registered outlets.</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;router module="MainRouter"&gt;
      &lt;!-- ... --&gt;
      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
      &lt;!-- ... --&gt;
    &lt;/router&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="javascript">fw.router({
  namespace: 'MainRouter',
  router: { /* ... */ }
  initialize: function() {
    // Prints: Registered outlets { 'main-view': function }
    console.log('Registered outlets', this.$router.outlets);
  }
});
</code></pre>

      <div class="note"><span class="label">NOTE:</span> If/When you call the <span class="inline-code">router.$outlet()</span> method that will also register whatever named outlet
        you refer to (if it is not already registered).</div>

    </div>
  </section>

  <a id="usage" class="section-anchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Usage</h1>
    </header>
    <div class="content">
      <p>To instantiate and use a <span class="inline-code">router</span> you have to tell footwork what part of your DOM to bind it with. This is done with a
        <span class="inline-code">&lt;router module=""&gt;</span> declaration in your markup.</p>

      <p>Just as a <span class="inline-code">viewModel</span> 'wraps' a section of your HTML providing the binding points (behavior) for that portion of your application. In a
        similar sense, a router also 'wraps' and provides all routing logic for that portion of your application.</p>

      <p>It works in essentially the same way as a <span class="inline-code">&lt;viewModel module=""&gt;</span> declaration would (which you can
        <a data-bind="$route: docLink('viewModel#initialization')">read about here</a>). However instead of controlling bindings within it (like a
        <span class="inline-code">viewModel</span>), the <span class="inline-code">router</span> controls any number of <span class="inline-code">&lt;outlet&gt;</span>
        declarations found within its scope, and conversly any <span class="inline-code">$route</span> bound elements found trigger on that parent
        <span class="inline-code">router</span>.</p>

      <h3>Example <span class="inline-code">&lt;router&gt;</span> wrapping:</h3>
<pre><code class="html">&lt;!-- main 'Router' wrapper --&gt;
&lt;router module="Router"&gt;
  &lt;div class="container"&gt;
    &lt;!-- controlled by 'Router' router --&gt;
    &lt;outlet name="outlet1"&gt;&lt;/outlet&gt;

    &lt;!-- triggers on 'Router' router --&gt;
    &lt;a href="/test" data-bind="$route"&gt;Test&lt;/a&gt;

    &lt;div data-bind="if: something"&gt;
      &lt;!-- controlled by 'Router' router --&gt;
      &lt;outlet name="outlet2"&gt;&lt;/outlet&gt;

      &lt;!-- child router 'SubRouter' wrapper --&gt;
      &lt;router module="SubRouter"&gt;
        &lt;!-- controlled by 'SubRouter' router --&gt;
        &lt;outlet name="outlet2"&gt;&lt;/outlet&gt;

        &lt;!-- triggers on 'SubRouter' router --&gt;
        &lt;a href="/subTest" data-bind="$route"&gt;Test&lt;/a&gt;
      &lt;/router&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/router&gt;</code></pre>

        <div class="note"><span class="label">NOTE:</span> You can read about <a href="#outlets" data-bind="$route">outlets</a> and
          <a href="#route-binding" data-bind="$route">$route binding</a> further down in their respective sections.</div>
    </div>
  </section>

  <a id="loading-registering" class="section-anchor"></a>
  <section name="loading-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading / Registering</h2>
    </header>
    <div class="content">
      <p>footwork.js supports both explicitly registering your routers ahead of time or automatically loading via AMD/RequireJS. In either case, the declarative
        <span class="inline-code">&lt;router module="[moduleName]"&gt; ... &lt;/router&gt;</span> syntax will trigger the loading (if necessary), initialization, and binding of the
        router.</p>

      <p>AMD/RequireJS is fully supported (and highly encouraged) for a number of reasons:</p>

      <ul>
        <li>It strongly encourages modularization and separation of concerns.</li>

        <li>Helps decouple your application and allow for easier testability.</li>

        <li>footwork can take advantage of its dependency resolution to automatically load and use resources for you as needed at runtime (<em>including the automatic loading and
          composing of entire views/pages/routes, components, or even applications</em>).</li>

        <li>Allows for easier debugging as non-compiled assets while still being buildable for release into a production environment.</li>

        <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, routers, and templates). None, some, or all of it...you
          choose what your users wait for.</li>
      </ul>

      <h3><span class="inline-code">router</span>/module resolution</h3>

      <p>There are 3 ways footwork will try to resolve your router when it encounters the declarative
        <span class="inline-code">&lt;router module="[moduleName]"&gt; ... &lt;/router&gt;</span> element you place in the DOM.</p>

      <p>Here they are in order of priority:</p>

      <ul>
        <li>Explicitly registered with a <span class="inline-code">fw.routers.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.routers.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.routers.defaultLocation()</span>).</li>
      </ul>

      <p>Registering a router explicitly with <span class="inline-code">fw.routers.register()</span> makes it immediately available. Any
        <span class="inline-code">&lt;router module="[moduleName]"&gt; ... &lt;/router&gt;</span> declarations encountered will be processed with no delay (the router is 'cached'
        when registered).</p>

      <p>The 2 methods <span class="inline-code">registerLocation()</span> and <span class="inline-code">defaultLocation()</span> tell footwork where it can download your router
        module (in the event you do not explicitly register it). In any case your markup will wait until the router is resolved prior to being initialized.</p>

      <div class="note"><span class="label">NOTE:</span> Nested routers (and components/viewModels) are independently resolved. It works as you would expect, with an outer-most
        container (router/etc) initializing/processing/binding and rendering, then any nested routers/etc get initialized (and so forth until the end).</div>

      <h3><em class="func-def">fw.routers.register<span>( <span class="param">'moduleName'</span>, <span class="param">router</span> )</span></em></h3>
      <h3>Cache a router/module ahead of time:</h3>
<pre><code class="javascript">// register a footwork router
var MainRouter = fw.router({ /* configuration object */ });
fw.routers.register('MainRouter', MainRouter);</code></pre>

      <h3><em class="func-def">fw.routers.registerLocation<span>( <span class="param">'moduleName'</span>, <span class="param">'path/to/module'</span> )</span></em></h3>
      <h3>Register the location of a router/module so footwork can load and bind it for you when needed:</h3>
<pre><code class="javascript">// Load MainRouter from: /routers/MainRouter.js (based on router/module name, case sensitive)
fw.routers.registerLocation('MainRouter', '/routers/');

// Load MainRouter from: /routers/DifferentFileName.js (specify full file name)
fw.routers.registerLocation('MainRouter', '/routers/DifferentFileName.js');</code></pre>

      <h3><em class="func-def">fw.routers.defaultLocation<span>( <span class="param">'path/to/viewModel/folder'</span> )</span></em></h3>
      <h3>Register the default location of routers/modules so footwork can load and bind them for you when needed:</h3>
<pre><code class="javascript">// Load all routers from /myRouters/[module-name].js (case sensitive)
fw.routers.defaultLocation('/myRouters/');</code></pre>

    </div>
  </section>

  <a id="module-formats" class="section-anchor"></a>
  <section name="module-formats">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Module Formats</h2>
    </header>
    <div class="content">
      <p>Loading your router/module in so that footwork can use it is done via a script loader.</p>
      <p>Both <a href="http://requirejs.org">AMD/RequireJS</a> and <a href="http://browserify.org" target="_blank">Browserify</a> are supported. However RequireJS is preferred as it will enable
      footwork to resolve your routers (and their dependencies) automatically at runtime as needed.</p>
      <p>The following example shows the RequireJS/AMD flavored version.</p>
<pre><code class="javascript">// File located in: /MainRouter.js
define(["footwork"],
  function(fw) {
    return fw.router({
      namespace: 'sprocket'
      // ...
    });
  }
);</code></pre>
    </div>
  </section>
  <a id="mixins" class="section-anchor"></a>
  <section name="mixins">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Mixins</h1>
    </header>
    <div class="content">
      <p>Mixins are about reusing behavior, functionality, and code whenever possible. They allow you to write various behaviors/logic and then later on combine
      and compose them as you want at runtime.</p>
      <p>The mixin functionality in footwork is provided via a library called <a href="https://github.com/a2labs/riveter" target="_blank">riveter</a>.
      All <span class="inline-code">fw.router()</span> based constructor functions are riveter constructor functions. Above and beyond the
      functionality outlined here, each object has various methods extended from riveter which can enable you to extend routers in
      various ways, I would encourage you to also <a href="https://github.com/a2labs/riveter" target="_blank">look at its documentation</a>.</p>

      <ul>
        <li><a data-bind="$route" href="#mixin-configuration">Configuration</a></li>
        <li><a data-bind="$route" href="#mixin-usage">Usage</a></li>
      </ul>

      <h3>Basic usage:</h3>
<pre><code class="javascript">var bigSprocket = { /* mixin configuration object */ };
var bikeSprocket = { /* mixin configuration object, detailed in the next section */ };

/**
 * Mixin behavior is applied to a router by passing it into the
 * fw.router() configuration object
 * NOTE: mixins are applied to the router in the order they are given.
 */
var MainRouter = fw.router({
  // ... router configuration object
  namespace: 'MainRouter',
  initialize: function(param) {
    this.type = param.type;
  },

  // mixins/behavior to include for each new 'Sprocket' router
  mixins: [ HomeSiteMixin ]
});</code></pre>
    </div>
  </section>

  <a id="mixin-configuration" class="section-anchor"></a>
  <section name="mixin-configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>Each mixin is simply a configuration object defining certain behaviors, functionality, and logic. The behavior you define will be added to each
        router instance it is configured with.</p>

      <h3>Mixin configuration object synopsis:</h3>
<pre><code class="javascript">// define 'HomeSiteMixin' as an object to serve as the configuration container
var HomeSiteMixin = {
  _preInit: function(param1, param2, ...) {
    /**
     * called prior to the initialize() method from the router configuration being called
     * params === params passed in at creation
     * this === the router
     */
  },

  mixin: {
    /**
     * these properties are added to 'this' object immediately upon creation, before
     * any methods (including _preInit) are called
     */
    function1: function() {
      // function that is extended onto the router object (this) upon creation
      // this === the router
    },
    function2: function() {
      // another function that is extended onto the router object (this) upon creation
      // this === the router
    },
    property1: 'someValue' // a raw property extended to the object
    // ...
  },

  _postInit: function() {
    /**
     * called after the initialize() method from the router configuration is called
     * this === the router
     */
  }
};</code></pre>

      <div class="note">
        <span class="label">NOTE:</span>
        <ul>
          <li>If you require some other type of object extension or mixin, as recommended above you should look at the
            <a href="https://github.com/a2labs/riveter" target="_blank">riveter documentation</a>.</li>

          <li>A router can have as many mixins as you want, and you can re-use them across as many differing routers/modules as you like (you can even use
            the same mixins on <a data-bind="$route: docLink('viewModel')">viewModel</a> and <a data-bind="$route: docLink('dataModel')">dataModel</a> instances!).</li>
        </ul>
      </div>
    </div>
  </section>

  <a id="mixin-usage" class="section-anchor"></a>
  <section name="mixin-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Example mixin usage</h2>
    </header>
    <div class="content">
      <p>Each mixin behavior is added to each new instance of the router that is created. This goes for ones instantiated automatically via declarative HTML, or
        directly/manually in javascript code.</p>

      <p>All mixins may be reused on both a standalone router and routers attributed with a component.</p>
      <h3>Example usage:</h3>
<pre><code class="javascript">// define the mixin configuration object
var bigSprocket = {
  _preInit: function(param) {
    this.isAwesome = (param.type === 'awesome' ? true : false);
    // this.isBig === true
  },
  mixin: {
    isBig: true,
    fitInSmallPlace: function() {
      return false;
    }
  }
};

// create a BigSprocket contructor and include the bigSprocket mixin
var BigSprocket = fw.router({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket ]
});

var mySprocket = new BigSprocket({ type: 'awesome' });
// mySprocket.fitInSmallPlace() === false
// mySprocket.isBig === true
// mySprocket.isAwesome === true</code></pre>
    </div>
  </section>

  <a id="outlets" class="section-anchor"></a>
  <section name="outlets">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Outlets</h1>
    </header>
    <div class="content">
      <p>Outlets are simply areas in your application where you can control what is displayed. Their placement in your application is designated by one or more
        <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations in your HTML. The <span class="inline-code">name=""</span> key is used by the router to
        target that specific outlet.</p>

<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;router module="MainRouter"&gt;
      &lt;!-- ... --&gt;
      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
      &lt;!-- ... --&gt;
    &lt;/router&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>When you tell an outlet what to show, you are telling it to load a component. Thus for each 'page' or view you want
      to display for an <span class="inline-code">outlet</span>, footwork will need one of the three following things:</p>

      <ul>
        <li>A corresponding view registered (cached/preloaded) via <span class="inline-code">fw.outlets.registerView()</span> or
          <a data-bind="$route: docLink('components#loading-registering')"><span class="inline-code">fw.components.register()</span></a></li>

        <li>A registered location where it can load the view via <span class="inline-code">fw.outlets.registerViewLocation()</span> or
          <a data-bind="$route: docLink('components#loading-registering')"><span class="inline-code">fw.components.registerLocation()</span></a></li>

        <li>A component/view available at the default component location (<span class="inline-code">fw.components.defaultLocation()</span>, see
          <a data-bind="$route: docLink('components#loading-registering')">component registration</a>).</li>
      </ul>

      <div class="note">
        <p><span class="label">NOTE:</span> You can tell an <span class="inline-code">&lt;outlet&gt;&lt;/outlet&gt;</span> to show <em>any</em> component, not just ones you
          register with <span class="inline-code">fw.outlets.registerView()</span> or <span class="inline-code">fw.outlets.registerViewLocation()</span>. Those methods are simply
          provided as a shortcut for creating a component and marking it as 'template-only'.</p>

        <p>Also remember that components can contain any depth and complexity of nested viewModels, components, routers, etc. This means you can even nest entire applications
          within the view of another, all with simple declarative syntax.</p>
      </div>
      <ul>
        <li><a data-bind="$route" href="#outlet-registering">Lazy Loading / Registering Views (components without a viewModel)</a></li>
        <li><a data-bind="$route" href="#outlet-usage">Usage</a></li>
      </ul>
    </div>
  </section>

  <a id="outlet-registering" class="section-anchor"></a>
  <section name="outlet-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lazy Loading / Registering Views (components without a viewModel)</h2>
    </header>
    <div class="content">
      <p>Because most things you might want to show in an outlet (pages/views) consist of only template code (they have no corresponding viewModel), footwork provides two shortcut
        methods for registering a template-only outlet view (ie: a page/view/template you can show in an <span class="inline-code">&lt;outlet&gt;&lt;/outlet&gt;</span>).</p>

      <ul>
        <li><span class="inline-code">fw.outlets.registerView()</span> - Cache a view/template for later use (available instantly, no download time).</li>

        <li><span class="inline-code">fw.outlets.registerViewLocation()</span> - Tell footwork where it can download it via AMD/RequireJS (dynamically/lazy loaded for you when
          requested). Since outlet views are just viewModel-less components, they are resolved just like any other
          <a data-bind="$route: docLink('components#loading-registering')">AMD/RequireJS loaded component</a>.</li>
      </ul>

      <p>Essentially they are ways to easily create/register a view you can use in an outlet.</p>

      <h3><em class="func-def">fw.outlets.registerView<span>( <span class="param">'viewName'</span>, <span class="param">'&lt;!-- template HTML --&gt;'</span> )</span></em></h3>
      <h3>Register/cache a view for later use:</h3>
<pre><code class="javascript">// Register the 'index-page' template view
fw.outlets.registerView('index-page', '&lt;p&gt;Welcome to footwork.js&lt;/p&gt;');

// Register a different view that has a nested component
fw.outlets.registerView('calendar-page', 'Calendar: &lt;calendar&gt;&lt;/calendar&gt;');
</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> It is generally recommended you load your templates via a module system such as RequireJS (don't just write them inline in a string as
          shown, that was only used as an example for reasons of brevity).</p><a data-bind="$route: docLink('namespacing')">namespacing</a>
        <p>For an example of how to do this check the <a href="/tutorials" data-bind="$route">tutorials page</a>, or alternatively just specify the location of the view via
          <span class="inline-code">fw.outlets.registerViewLocation()</span>.</p>
      </div>

      <h3><em class="func-def">fw.outlets.registerViewLocation<span>( <span class="param">'viewName'</span>, <span class="param">'/path/to/template'</span> )</span></em></h3>
      <h3><em class="func-def">fw.outlets.registerViewLocation<span>( <span class="param">[ 'viewName', 'viewName2', ... ]</span>, <span class="param">'/path/to/template/'</span> )</span></em></h3>
      <h3>Tell footwork where it can download a view via AMD/RequireJS:</h3>
<pre><code class="javascript">// Register location of the 'index-page' template view
fw.outlets.registerViewLocation('index-page', '/pages/index-page.html');

/**
 * Footwork will append the filename if you end it with a trailing slash (/)
 * The following will try to load '/otherPages/calendar-page.html' when needed
 */
fw.outlets.registerViewLocation('calendar-page', '/otherPages/');

// Register location for multiple views (the same filename appending occurs):
fw.outlets.registerViewLocation(['calendar-page', 'about-page'], '/otherPages/');
</code></pre>
    </div>
  </section>

  <a id="outlet-usage" class="section-anchor"></a>
  <section name="outlet-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Usage</h2>
    </header>
    <div class="content">
      <p>Once footwork knows how to resolve your outlet view it can be used in your application. From that point you need only place whatever
        <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations you want in the HTML and then change/set them via the
        <span class="inline-code">router.$outlet()</span> method.</p>

      <h3><em class="func-def">router.$outlet<span>( <span class="param">'outletName'</span>, <span class="param">'viewName'</span>, <span class="param">onComplete(containingElement)</span> )</span></em></h3>
      <h3><em class="func-def">router.$outlet<span>( <span class="param">'outletName'</span>, <span class="param">'viewName'</span>, <span class="param">{ onComplete: function(containingElement), onFailure: function(error) }</span> )</span></em></h3>
      <h3>Trigger an outlet to display a component, optionally providing an onComplete() callback and/or parameters to its viewModel.</h3>
<pre><code class="javascript">fw.router({
  namespace: 'MainRouter',
  routes: [
    {
      route: '/',
      controller: function() {
        // route changed to '/', make the 'main-view' outlet show the 'index-page' view
        this.$outlet('main-view', 'index-page');
      }
    }, {
      route: '/about',
      controller: function() {
        // route changed to '/about', make the 'main-view' outlet show the 'about-page' view
        this.$outlet('main-view', 'about-page', function(element) {
          // callback triggered after about-page is loaded
          console.log('About page is loaded inside of', element);
        });
      }
    }
  ]
});
</code></pre>

      <p>You can also pass an <span class="inline-code">options</span> object to the <span class="inline-code">router.$outlet()</span> method. This object can contain the
        following:</p>

      <ul>
        <li><span class="inline-code">params:</span> - (<em>optional</em>) Object passed to the <span class="inline-code">initialize()</span> method of the viewModel (if your view/component has a viewModel).</li>
        <li><span class="inline-code">onComplete:</span> - (<em>optional</em>) A callback function which is run after the new view/component is loaded (same as above).</li>
      </ul>
<pre><code class="javascript">// ...
{
  route: '/about',
  controller: function() {
    this.$outlet('main-view', 'about-page', {
      // params object passed to the viewModel initialize() method
      params: { thisObject: 'isPassedToTheComponent' },

      // callback which is run after it is loaded
      onComplete: function(element) {
        console.log('About page is loaded inside of', element);
      }
    });
  }
}
// ...
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Remember that in addition to passing arguments directly from a route, you can also leverage the
      powerful <a data-bind="$route: docLink('namespacing')">namespacing</a> or <a data-bind="$route: docLink('broadcastable-receivable')">broadcastable/receivable</a>
      features of footwork to facilitate communication/initialization of your view component.</div>
    </div>
  </section>

  <a id="route-binding" class="section-anchor"></a>
  <section name="route-binding">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">$route Binding</h1>
    </header>
    <div class="content">
      <p>In order to make your links and other elements work with the router, footwork needs to know about them. This is done with the <span class="inline-code">$route</span>
        binding.</p>

      <p>The <span class="inline-code">$route</span> binding is simply a <a href="http://knockoutjs.com/documentation/custom-bindings.html" target="_blank">custom knockout binding</a>
        which is created by footwork. This binding allows footwork to correctly connect your DOM element event (click, by default) to a router action.</p>

      <p>Whenever footwork encounters the <span class="inline-code">$route</span> binding it will traverse up the DOM node path searching for the nearest parent router. Whenever
        the designated event occurs on that element it will trigger the state change as described on that router.</p>

      <h3><span class="inline-code">$route</span> binding basic example:</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;router module="MainRouter"&gt;
      &lt;div class="navigation"&gt;
        &lt;!-- 'click' events on these will route application to their href="" paths --&gt;
        &lt;a href="/" data-bind="$route"&gt;Home Page&lt;/a&gt;
        &lt;a href="/about" data-bind="$route"&gt;About Page&lt;/a&gt;
      &lt;/div&gt;

      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
    &lt;/router&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <div class="note"><span class="label">NOTE:</span> If you do not wish to use the <span class="inline-code">$route</span> binding to trigger state changes you can always just
        use the <span class="inline-code">router.setState()</span> method.</div>
    </div>
  </section>

  <a id="binding-options" class="section-anchor"></a>
  <section name="binding-options">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Binding Options</h2>
    </header>
    <div class="content">
      <p>The <span class="inline-code">$route</span> binding has a few optional parameters.</p>
      <ul>
        <li><span class="inline-code">url:</span> - <span class="inline-code">string / callback()</span> The route to send the application to.</li>
        <li><span class="inline-code">on:</span> - <span class="inline-code">string</span> The event to trigger the action on (click, by default).</li>
        <li><span class="inline-code">handler:</span> - <span class="inline-code">function(event, url)</span> Callback handler for the event.</li>
        <li><span class="inline-code">addActiveClass:</span> - <span class="inline-code">boolean</span> Flag indicating whether or not the 'active' class should be added to the element.</li>
        <li><span class="inline-code">activeClass:</span> - <span class="inline-code">string</span> The classname to add to the element when the route is active (default is 'active').</li>
      </ul>

      <h3><span class="inline-code">url:</span> - <span class="inline-code">string / callback()</span> The URL/HREF/route to send the application to:</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- If not provided, footwork will attempt to find the url for the action on the href="" attribute. --&gt;
  &lt;a data-bind="$route: { url: '/about' }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>

      <div class="note"><span class="label">NOTE:</span> Footwork will also set the <span class="inline-code">href=""</span> attribute to the appropriate URL after the router
        has initialized the <span class="inline-code">$route</span> binding.</div>

      <h3><span class="inline-code">on:</span> - <span class="inline-code">string</span> The event to trigger the action on (click, by default):</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- Trigger the action on a double-click --&gt;
  &lt;a data-bind="$route: { url: '/about', on: 'dblclick' }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>

      <h3><span class="inline-code">handler:</span> - <span class="inline-code">function(event, url)</span> Callback handler for the event:</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- Trigger the action with a custom handler --&gt;
  &lt;a data-bind="$route: { url: '/about', handler: clickHandler }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>
<pre><code class="javascript">// example viewModel showing the handler from above
var MainViewModel = fw.viewModel({
  // ...
  initialize: function() {
    this.clickHandler = function(event, url) {
      console.log('Route Destination:', url);

      // must prevent the default action on an &lt;a&gt; tag (otherwise it will reload the page)
      event.preventDefault();

      // tell footwork to route to the url (false === do not route)
      return true;
    }
  }
  // ...
});
</code></pre>
    </div>
  </section>

  <a id="misc" class="section-anchor"></a>
  <section name="misc">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Misc / Utility</h2>
    </header>
    <div class="content">
      <p>Miscelaneous useful and utility methods.</p>
      <ul>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-getAll">fw.routers.getAll()</a></span> - Return list of instantiated routers.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-baseRoute">fw.routers.baseRoute()</a></span> - Get or set the beginning portion of a route to ignore for the given path.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-activeRouteClassName">fw.routers.activeRouteClassName()</a></span> - Get or set the class which is added to an active <span class="inline-code">$route</span> bound element.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-disableHistory">fw.routers.disableHistory()</a></span> - Enable or disable history (or get the current setting).</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-html5History">fw.routers.html5History()</a></span> - Returns true if using HTML5 history.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#isRegistered">fw.routers.isRegistered()</a></span> - Return true/false based on whether a router module is registered.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#getRegistered">fw.routers.getRegistered()</a></span> - Gets the registered router module.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#getResourceLocation">fw.routers.getResourceLocation()</a></span> - Gets the location footwork will try to download a router module.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#getFileName">fw.routers.getFileName()</a></span> - Get the filename for the given router module.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#fileExtensions">fw.routers.fileExtensions()</a></span> - Get the file extension for a given router module.</li>
      </ul>
    </div>
  </section>

  <a id="routers-getAll" class="section-anchor"></a>
  <section name="routers-getAll">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.getAll<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.getAll<span>( <span class="param">'namespace'</span> )</span></em></h3>
      <h3>Return list of instantiated routers:</h3>
<pre><code class="javascript">var routers = fw.routers.getAll();
// routers === { MainRouter: router, WidgetRouter: router }

var routers = fw.routers.getAll('WidgetRouter');
// routers === { WidgetRouter: router }</code></pre>
    </div>
  </section>

  <a id="routers-baseRoute" class="section-anchor"></a>
  <section name="routers-baseRoute">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.baseRoute<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.baseRoute<span>( <span class="param">'/path/to/ignore'</span> )</span></em></h3>
      <h3>Get or set the beginning portion of a route to ignore for the given path:</h3>
<pre><code class="javascript">// fw.routers.baseRoute() === ''
fw.routers.baseRoute('/home/directory'); // routers will ignore '/home/directory' at beginning of url</code></pre>
    </div>
  </section>

  <a id="routers-activeRouteClassName" class="section-anchor"></a>
  <section name="routers-activeRouteClassName">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.activeRouteClassName<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.activeRouteClassName<span>( <span class="param">'className'</span> )</span></em></h3>
      <h3>Get or set the class which is added to an active <span class="inline-code">$route</span> bound element:</h3>
<pre><code class="javascript">// fw.routers.activeRouteClassName() === 'active' // default === 'active'
// active routes will now have 'currentlyActive' added to their className
fw.routers.activeRouteClassName('currentlyActive');</code></pre>
    </div>
  </section>

  <a id="routers-disableHistory" class="section-anchor"></a>
  <section name="routers-disableHistory">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.disableHistory<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.disableHistory<span>( <span class="param">isDisabled</span> )</span></em></h3>
      <h3>Enable or disable history (or get the current setting):</h3>
<pre><code class="javascript">// fw.routers.disableHistory() === false (default)
fw.routers.disableHistory(true); // history now disabled, but app still navigable</code></pre>
    </div>
  </section>

  <a id="routers-html5History" class="section-anchor"></a>
  <section name="routers-html5History">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.html5History<span>()</span></em></h3>
      <h3>Get a boolean indicating whether or not footwork is using the HTML5 history API:</h3>
<pre><code class="javascript">// fw.routers.html5History() === true (when using chrome)
fw.routers.html5History(); // === false when using &lt;=IE8</code></pre>
      <div class="note"><span class="label">NOTE:</span> You can force HTML4 (hash-based) routing by running this code before DOM onload: <span class="inline-code">window.History = { options: { html4Mode: true } };</span></div>
    </div>
  </section>

  <a id="isRegistered" class="section-anchor"></a>
  <section name="isRegistered">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.isRegistered<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Return true or false based on whether or not there is a router that has been registered under 'moduleName':</h3>
<pre><code class="javascript">var MainRouter = fw.router({
  namespace: 'MainRouter'
});

fw.routers.register('MainRouter', MainRouter);
// fw.routers.isRegistered('MainRouter') === true</code></pre>
    </div>
  </section>

  <a id="getRegistered" class="section-anchor"></a>
  <section name="getRegistered">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.getRegistered<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Return router that has been registered under 'moduleName':</h3>
<pre><code class="javascript">// Explicit registration
var MainRouter = fw.router({ /* ... configuration object */ });
fw.routers.register('MainRouter', MainRouter);
// fw.routers.getRegistered('MainRouter') === MainRouter</code></pre>
    </div>
  </section>

  <a id="getResourceLocation" class="section-anchor"></a>
  <section name="getResourceLocation">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.getResourceLocation<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Get the path footwork will attempt to load for the given 'moduleName':</h3>
<pre><code class="javascript">fw.routers.registerLocation('MainRouter', '/path/to/router/folder');
// fw.routers.getResourceLocation('MainRouter') === '/path/to/router/folder'</code></pre>
    </div>
  </section>

  <a id="getFileName" class="section-anchor"></a>
  <section name="getFileName">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.getFileName<span>( <span class="param">'moduleName'</span> )</span></em></h3>
      <h3>Get the file name that footwork will appended to the path when downloading the router:</h3>
<pre><code class="javascript">var fileNameForMainRouter = fw.routers.getFileName('MainRouter'); // === MainRouter.js

/**
 * If the router was explicitly registered (cached), then null is returned for any
 * fileType because the file name will never be used.
 */
fw.routers.register('MainRouter', fw.router({ /* configuration object */ }) );
var fileNameForMainRouter = fw.routers.getFileName('MainRouter'); // === null
</code></pre>
    </div>
  </section>

  <a id="fileExtensions" class="section-anchor"></a>
  <section name="fileExtensions">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.fileExtensions<span>( <span class="param">'.ext'</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.fileExtensions<span>( <span class="param">function(moduleName) { ... }</span> )</span></em></h3>
      <h3>Specify the extension to append to an AMD/RequireJS loaded router path when it does not have an extension specified (ie: full file name not specified):</h3>
<pre><code class="javascript">// Explicitely set the extension
fw.routers.fileExtensions('.jscript'); // append router module files with '.jscript'

// You can also specify a function() whose return value is used as the extension.
fw.routers.fileExtensions(function(moduleName) {
  if(moduleName === 'MainRouter') {
    return '.jscript';
  } else {
    return '.js';
  }
});</code></pre>

</article>

<div id="metaData">
{
  "title": "Routing",
  "description": "Initializing and managing application state.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "configuration",
      "title": "Configuration",
      "subSections": [
        { "anchor": "routes",
          "title": "Routes List" },
        { "anchor": "route",
          "title": "Route Definition" },
        { "anchor": "router-properties",
          "title": "Router Properties" }
      ] },
    { "anchor": "usage",
      "title": "Usage",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "loading-registering",
          "title": "Lazy Loading / Registering Routers" },
        { "anchor": "module-formats",
          "title": "Module Formats" }
      ] },
    { "anchor": "mixins",
      "title": "Mixins",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "mixin-configuration",
          "title": "Configuration" },
        { "anchor": "mixin-usage",
          "title": "Usage" }
      ] },
    { "anchor": "outlets",
      "title": "Outlets",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "outlet-registering",
          "title": "Lazy Loading / Registering Views" },
        { "anchor": "outlet-usage",
          "title": "Usage" }
      ] },
    { "anchor": "route-binding",
      "title": "$route Binding",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "binding-options",
          "title": "Binding Options" }
      ] },
    { "anchor": "misc",
      "title": "Misc / Utility",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "routers-getAll",
          "title": "fw.routers.getAll()" },
        { "anchor": "routers-baseRoute",
          "title": "fw.routers.baseRoute()" },
        { "anchor": "routers-activeRouteClassName",
          "title": "fw.routers.activeRouteClassName()" },
        { "anchor": "routers-disableHistory",
          "title": "fw.routers.disableHistory()" },
        { "anchor": "routers-html5History",
          "title": "fw.routers.html5History()" },
        { "anchor": "isRegistered",
          "title": "fw.routers.isRegistered()" },
        { "anchor": "getRegistered",
          "title": "fw.routers.getRegistered()" },
        { "anchor": "getResourceLocation",
          "title": "fw.routers.getResourceLocation()" },
        { "anchor": "getFileName",
          "title": "fw.routers.getFileName()" },
        { "anchor": "fileExtensions",
          "title": "fw.routers.fileExtensions()" }
      ] }
  ]
}
</div>
