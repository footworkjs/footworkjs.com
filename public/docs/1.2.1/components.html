<article>
  <div class="version-display" data-bind="text: versionDisplay"></div>
  <a id="introduction" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Introduction</h1>
    </header>
    <div class="content">
      <p>At its most basic level, a <span class="inline-code">component</span> is essentially a
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> + <em>template</em> composed together and inserted into
        the DOM.</p>


      <p>FootworkJS extends the <span class="inline-code">component</span> feature found in
        <a href="http://knockoutjs.com" target="_blank">KnockoutJS</a> 3.2+ to enable many additional features, some of which being:</p>

      <ul>
        <li>Automatic instantiation and binding of a <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> instance against a <em>template</em>.</li>
        <li>Automatic resolution/download at runtime via AMD/RequireJS.</li>
        <li>Expressive and semantic <span class="inline-code">&lt;custom-elements&gt;&lt;/custom-elements&gt;</span></li>
        <li>Unlimited nesting capability.</li>
        <li>Lifecycle events.</li>
        <li>Animations.</li>
        <li>Can be compiled and minified into assets along with all other application code.</li>
        <li><span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> integration (easily manage components and state)</li>
      </ul>

      <p>Since FootworkJS uses KnockoutJS components as its base implementation it supports (by proxy) all of the same features found in the
        <span class="inline-code">component</span> feature of KnockoutJS, for further documentation (beyond what is contained here) please see the
        <a href="http://knockoutjs.com/documentation/component-overview.html" target="_blank">KnockoutJS component documentation</a>.</p>
    </div>
  </section>

  <a id="usage" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="title">Usage</h1>
    </header>
    <div class="content">
      <p>There are principally 2 things Footwork uses to instantiate and compose a <span class="inline-code">component</span>:</p>

      <ul>
        <li>The template/HTML/DOM to bind against.</li>
        <li>The <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> which the template/HTML/DOM is bound to.</li>
      </ul>

      <p>FootworkJS will use either the the custom element name or name provided by the
        <a href="http://knockoutjs.com/documentation/component-binding.html" target="_blank">component binding</a> to resolve and wire-up the designated
        component.</p>

      <h3 class="top">Example <span class="inline-code">component</span> declarations inside of an HTML file:</h3>
<div class="file-location">index.html</div>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;Look at this awesome Sprocket:&lt;/div&gt;

    &lt;!-- this will load the 'sprocket' component here --&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;!-- NOTE: only lowercase alpha-numeric and dash (-) characters are allowed for custom elements --&gt;

    &lt;!-- this loads the 'sprocket' component using the standard knockout component binding --&gt;
    &lt;div data-bind="component: 'sprocket'"&gt;&lt;/div&gt;

    &lt;!-- this loads the 'sprocket' component using KnockoutJS containerless virtual elements --&gt;
    &lt;!-- ko component: 'sprocket'" --&gt;&lt;!-- /ko --&gt;

    &lt;!-- this will load the 'sprocket' component while passing some parameters from the current
         context into the viewModel of the component --&gt;
    &lt;sprocket params="someValueFromParent: someValue"&gt;&lt;/sprocket&gt;

    &lt;!-- if the component has no viewModel defined you can pass $viewModel into the params and
         footwork will create a viewModel with the data supplied (which you can then bind against) --&gt;
    &lt;div data-bind="foreach: arrayOfObjects"&gt;
      &lt;!-- here we pass in the current context ($data) as the $viewModel --&gt;
      &lt;sprocket params="$viewModel: $data"&gt;&lt;/sprocket&gt;
    &lt;/div&gt;

    &lt;script src="/application.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <div class="note">
        <span class="label">NOTE:</span> You can nest <span class="inline-code">&lt;component&gt;</span> /
        <span class="inline-code">&lt;viewModel&gt;</span> /
        <span class="inline-code">&lt;dataModel&gt;</span> /
        <span class="inline-code">&lt;router&gt;</span> declarations within
          one another, Footwork will pull in resources and wire it up as needed at runtime.
      </div>

      <p>The other piece necessary to use a <span class="inline-code">component</span> is the
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> which houses the logic/behavior the HTML is bound against.
        Those are provided either explicitly via direct registration or by telling Footwork where it can find (download/resolve) them. For that,
        see <a data-bind="$route" href="#load-register">component registration</a>.</p>

      <p>If no <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
          <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> is supplied during the registration of a
          <span class="inline-code">component</span> then Footwork will supply a 'default' <span class="inline-code">viewModel</span>. This allows
          you to create template-only <span class="inline-code">components</span>.</p>
    </div>
  </section>

  <a id="load-register" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="load-register">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Registering and Loading</h2>
    </header>
    <div class="content">
      <p>Once an element not recognized as being normal HTML is encountered Footwork will process it as a component. This begins with the resolving of
        its immediate dependencies (the <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> and the <span class="inline-code">template</span>).</p>

      <p>There are 3 ways Footwork will try to resolve both of these assets for your <span class="inline-code">component</span> once it encounters the
        <span class="inline-code">&lt;component-name&gt;&lt;/component-name&gt;</span> or
        <span class="inline-code">&lt;div data-bind="component: 'component-name'"&gt;&lt;/div&gt;</span> markup.</p>

      <p>They are as follows (in order of priority):</p>

      <ul>
        <li>They have already been explicitly registered with a <span class="inline-code"><a data-bind="$route" href="#components-register">fw.components.register()</a></span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code"><a data-bind="$route" href="#components-registerLocation">fw.components.registerLocation()</a></span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code"><a data-bind="$route" href="#components-defaultLocation">fw.components.defaultLocation()</a></span>).</li>
      </ul>

      <div class="note"><span class="label">NOTE [<em>advanced</em>]:</span> You can also write your own
        <a href="http://knockoutjs.com/documentation/component-loaders.html" target="_blank">custom loader</a> if you want to use a different method/library or logic to resolve
        your component dependencies.</div>

      <p>The following method is used to explicitly register a component and its assets. This means the <span class="inline-code">component</span> will
        load <em>synchronously</em> as the rest of the markup is bound/initialized.</p>

      <a id="components-register" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.register<span>( <span class="param">'name'</span>, <span class="param">optionsObject</span> )</span></div>
        </div>
        <div class="description">Register (cache) a component under a specified <span class="inline-code">name</span> for later use.</div>
      </div>
<pre><code class="javascript">// Register a Footwork viewModel
fw.components.register('sprocket', {
  viewModel: fw.viewModel.create({ /* ... configuration object ... */ }),
  template: '&lt;div data-bind="text: numberOfCogs"&gt;&lt;/div&gt;'
});

// Register a Footwork dataModel
fw.components.register('sprocket', {
  dataModel: fw.dataModel.create({ /* ... configuration object ... */ }),
  template: '&lt;div data-bind="text: numberOfCogs"&gt;&lt;/div&gt;'
});

// Register a Footwork router
fw.components.register('sprocket', {
  router: fw.router.create({ /* ... configuration object ... */ }),
  template: '&lt;div data-bind="text: numberOfCogs"&gt;&lt;/div&gt;'
});

// Register a regular constructor function
fw.components.register('sprocket', {
  viewModel: function() { this.numberOfCogs = '12'; },
  template: '&lt;div data-bind="text: numberOfCogs"&gt;&lt;/div&gt;'
});</code></pre>

      <div class="note">
        <span class="label">NOTE:</span>
        <ul>
          <li>FootworkJS fully supports (by proxy) regular KnockoutJS component registration (See:
            <a href="http://knockoutjs.com/documentation/component-registration.html" target="_blank">KnockoutJS component registration</a>)</li>

          <li>Registering components explicitly is not necessary if you are using AMD/RequireJS and tell Footwork where it can resolve/download them (see
          <span class="inline-code"><a data-bind="$route" href="#components-registerLocation">fw.components.registerLocation()</a></span> and
          <span class="inline-code"><a data-bind="$route" href="#components-defaultLocation">fw.components.defaultLocation()</a></span> down below).</li>

          <li>It is recommended you load these assets (the viewModel and template) in via some other means. Footwork preferences loading them with
            <a href="http://requirejs.org">AMD/RequireJS</a> because of its inherent async capabilities/runtime dependency resolution/etc, however if
            <a href="http://browserify.org" target="_blank">Browserify</a> is more your taste that will work just as well.</li>
        </ul>
      </div>

      <p>Another option available is to tell FootworkJS where your <span class="inline-code">component</span> assets are and let it take care of
        downloading/resolving (via AMD/RequireJS) and initializing them for you. The following methods
        (<span class="inline-code">fw.components.registerLocation()</span> and <span class="inline-code">fw.components.defaultLocation()</span>)
        outline how to do that.</p>

      <a id="components-registerLocation" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.registerLocation<span>( <span class="param">'name'</span> | <span class="param">/RegExp/</span>, <span class="param">{ viewModel: 'path/to/viewModel', template: 'path/to/template' }</span>, <span class="param">folderOffset</span> )</span></div>
          <div class="func-def"><span>fw.components</span>.registerLocation<span>( <span class="param">'name'</span> | <span class="param">/RegExp/</span>, <span class="param">{ combined: 'path/to/combinedComponentFile' }</span>, <span class="param">folderOffset</span> )</span></div>
          <div class="func-def"><span>fw.components</span>.registerLocation<span>( <span class="param">'name'</span> | <span class="param">/RegExp/</span>, <span class="param">'path/to/viewModelAndTemplate'</span>, <span class="param">folderOffset</span> )</span></div>
        </div>
        <div class="description">Tell Footwork where to find the component <span class="inline-code">name</span> using the supplied configuration.</div>
      </div>
<pre><code class="javascript">/**
 * Register component under 'sprocket' using individual paths for the viewModel and template files.
 * The file name will be appended using the name of the component + .ext
 */
fw.components.registerLocation('sprocket', {
  viewModel: '/components/bikeParts/', // load from /components/bikeParts/sprocket.js
  template: '/components/bikeParts/' // load from /components/bikeParts/sprocket.html
});

// Same as above, but using a dataModel instead (you can also load/compose a router with a component as well)
fw.components.registerLocation('sprocket', {
  dataModel: '/components/bikeParts/', // load from /components/bikeParts/sprocket.js
  template: '/components/bikeParts/' // load from /components/bikeParts/sprocket.html
});

// You can specify the full file name (ie: use this if the file name does not conform to what Footwork expects)
fw.components.registerLocation('sprocket', {
  viewModel: '/components/bikeParts/TheSprocket.js', // load from /components/bikeParts/TheSprocket.js
  template: '/components/bikeParts/theSprocket.html' // load from /components/bikeParts/theSprocket.html
});

// You can tell footwork to prepend with a folder name using the folderOffset option
fw.components.registerLocation('sprocket', {
  viewModel: '/components/', // load from /components/sprocket/sprocket.js
  template: '/components/' // load from /components/sprocket/sprocket.html
}, true);

// Specify the 'combined' module to be downloaded (see the 'Module Formats' section on this page)
fw.components.registerLocation('sprocket', { combined: '/components/' }); // load from /components/sprocket.js
fw.components.registerLocation('sprocket', { combined: '/components/theSprocket.js' }); // load from /components/theSprocket.js

// You can also specify the path to many components at once (Footwork will append the appropriate file name):
fw.components.registerLocation(['sprocket', 'wheel'], {
  viewModel: '/components/bikeParts/', // load from /components/bikeParts/component-name.js
  template: '/components/bikeParts/' // load from /components/bikeParts/component-name.html
});

// load viewModel from /components/sprocket/sprocket.js and template from /components/sprocket/sprocket.html
fw.components.registerLocation('sprocket', '/components/sprocket/');
</code></pre>

      <div class="note"><span class="label">NOTE:</span> Once you <span class="inline-code">registerLocation()</span> a component as being being a 'combined'
        format, Footwork will preferentially choose that path/module type when trying to resolve the component. So in short, make sure you only specify the location of either the
        viewModel+template OR combined modules (not both) for any given component.</div>

      <a id="components-defaultLocation" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.defaultLocation<span>( <span class="param">'name'</span>, <span class="param">{ viewModel: 'path/to/viewModel', template: 'path/to/template' }</span> )</span></div>
          <div class="func-def"><span>fw.components</span>.defaultLocation<span>( <span class="param">'name'</span>, <span class="param">{ combined: 'path/to/combinedComponentFile' }</span> )</span></div>
          <div class="func-def"><span>fw.components</span>.defaultLocation<span>( <span class="param">'name'</span>, <span class="param">'path/to/combinedComponentFile'</span> )</span></div>
        </div>
        <div class="description">Tell Footwork where to look for a <span class="inline-code">component</span> if it isn't registered explicitly (ie:
          when all else fails).</div>
      </div>
<pre><code class="javascript">// Load components using individual paths for the viewModel and template files.
fw.components.defaultLocation({
  viewModel: '/viewModels/', // load from /viewModels/component-name.js
  template: '/templates/' // load from /templates/component-name.html
});

// Load components in combined format by default from /components/component-name.js
fw.components.defaultLocation('/components/');
</code></pre>
    </div>
  </section>

  <a id="module-formats" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="module-formats">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Module Formats</h2>
    </header>
    <div class="content">
      <p>FootworkJS templates are loaded as plain HTML files, but the corresponding
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> is loaded as a javascript (AMD) module and has a special
        structure. A <span class="inline-code">component</span> can either be registered explicitly, or resolved via a
        script loader (by default, AMD/RequireJS).</p>

      <p>Both <a href="http://requirejs.org">AMD/RequireJS</a> and <a href="http://browserify.org" target="_blank">Browserify</a> are supported. However RequireJS is preferred as
        it will enable Footwork to resolve your <span class="inline-code">component</span> (and its dependencies) automatically at runtime as needed.</p>

      <p>The following examples show <em>RequireJS/AMD</em>-flavored modules.</p>

      <p>This first example shows a basic <span class="inline-code">viewModel</span> / <span class="inline-code">template</span> split:</p>

      <div class="file-location">sprocket-viewModel.js</div>
<pre><code class="javascript">define(["footwork"],
  function(fw) {

    return fw.viewModel.create({
      initialize: function(params) {
        // ...
      }
    });

  }
);</code></pre>

      <div class="file-location">sprocket-view.html</div>
<pre><code class="html">&lt;div class="sprocket"&gt;
  &lt;div&gt;Sprocket&lt;/div&gt;
  Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
  Description: &lt;span data-bind="text: description"&gt;&lt;/span&gt;
&lt;/div&gt;</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> You can return any constructor function or plain object from your modules and the
          <span class="inline-code">component</span> will be composed with it (you don't have to return a Footwork
          <span class="inline-code">viewModel</span> constructor as shown).</p>
      </div>

      <p>The following shows how to create a <em>combined</em> <span class="inline-code">component</span> which contains both the
        constructor function/<span class="inline-code">viewModel</span> and <span class="inline-code">template</span> HTML in one file.</p>

      <a id="fw-component" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw</span>.component<span>( <span class="param">configurationObject</span> )</span></div>
        </div>
        <div class="description">Create a <em>combined</em> <span class="inline-code">component</span> definition based on the
          provided <span class="inline-code">viewModel</span> / <span class="inline-code">dataModel</span> / <span class="inline-code">router</span> +
          <span class="inline-code">template</span> definition.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">object{}</span> Combined <span class="inline-code">component</span> module.</span>
        </div>
      </div>
<pre><code class="javascript">define(["footwork"],
  function(fw) {

    return fw.component({
      viewModel: fw.viewModel.create({ /* ... */ }),
      template: '&lt;div class="sprocket"&gt;&lt;!-- template HTML --&gt;&lt;/div&gt;'
    });

  }
);</code></pre>

      <div class="note"><span class="label">NOTE:</span> You can use any constructor function or plain object as the viewModel for your component modules (you don't have to use a
        Footwork viewModel constructor as shown).</div>
    </div>
  </section>

  <a id="lifecycle" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="lifecycle">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lifecycle</h2>
    </header>
    <div class="content">
      <p>The lifecycle of a <span class="inline-code">component</span> is directly tied to the
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router')">router</a></span> which it is bound against.</p>

      <p>For information concerning what lifecycle hooks and events are available/occur, see the relevant documentation (dependent on your particular
        use):</p>

      <ul>
        <li><span class="inline-code"><a data-bind="$route: docLink('viewModel#lifecycle')">viewModel Lifecycle</a></span></li>
        <li><span class="inline-code"><a data-bind="$route: docLink('dataModel#lifecycle')">dataModel Lifecycle</a></span></li>
        <li><span class="inline-code"><a data-bind="$route: docLink('router#lifecycle')">router Lifecycle</a></span></li>
      </ul>
    </div>
  </section>

  <a id="animating-components" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="animating-components">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Animating Components</h2>
    </header>
    <div class="content">
      <p>Often times it is desirable to animate the loading of a new <span class="inline-code">component</span>. FootworkJS builds animation capability
        into every <span class="inline-code">&lt;component&gt;</span> and
        <span class="inline-code"><a data-bind="$route: docLink('router#animating-views')">router &lt;outlet&gt;</a></span>.</p>

      <p>To use the built in animation capability you first need to include the companion <span class="inline-code">CSS</span> which has the relevant
        animation code in it.</p>
<div class="file-location">index.html</div>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;!-- The animation.css asset is included with FootworkJS in the dist folder --&gt;
    &lt;link rel="stylesheet" href="bower_components/footwork/dist/animation/animation.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- This component will load in the template which contains the elements
         that have the animation class on them. --&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <div class="note">
        <p><span class="label">NOTE:</span> If you would rather build the animations into your own CSS assets, or want to customize the way they work
          then you will want to use one of the either <span class="inline-code">.less</span> or <span class="inline-code">.scss</span> versions
          and extend from those. All of the animation assets are located in <span class="inline-code">dist/animation</span>.</p>
        <p><em>TODO: Examples of customizations and how to add new animations.</em></p>
      </div>

      <p>After you have the animation css/styles being loaded you will need to add one of the available animation
        classes to the top-level container elements inside of your <span class="inline-code">components</span>.</p>

      <p>Lets say that we have the <span class="inline-code">template</span> for <span class="inline-code">&lt;my-component&gt;</span> defined as follows:</p>
<div class="file-location">my-component-template.html</div>
<pre><code>&lt;!-- The specified animation class will dictate how it animates into view --&gt;
&lt;div class="fade-in"&gt;
  &lt;p&gt;All of the content inside of this view will fade-in!&lt;/p&gt;
&lt;/div&gt;

&lt;!-- You can also animate more than one thing, it simply needs to be a
     top-level element and have an animation class on it --&gt;
&lt;div class="fade-in-from-top"&gt;
  &lt;p&gt;All of the content inside of this view will fade-in-from-top!&lt;/p&gt;
&lt;/div&gt;</code></pre>

      <p>Currently available animations by default:</p>
      <ul>
        <li><em>fade-in</em></li>
        <li><em>fade-in-from-top</em></li>
        <li><em>fade-in-from-bottom</em></li>
        <li><em>fade-in-from-left</em></li>
        <li><em>fade-in-from-right</em></li>
      </ul>

      <p><em>Default Animations</em></p>
      <p>Note that if you are specifying an animation class inside of a component which has no
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> supplied then it will use the default
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span> which has a predefined
        <span class="inline-code">sequenceAnimations</span> value of <span class="inline-code">0</span>. This means that by default Footwork
        will not ensure there is an interval period before animating a default
        <span class="inline-code"><a data-bind="$route: docLink('viewModel')">viewModel</a></span>.</p>


      <p class="note"><span class="label">NOTE:</span> You can change the default animation iteration value by setting
        <span class="inline-code">fw.settings.sequenceAnimations</span> to another value.</p>

      <a id="fw-settings-sequenceAnimations" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-circle"></span></div>
          <div class="func-def"><span>fw.settings</span>.sequenceAnimations</div>
        </div>
        <div class="description">Variable which stores the default sequence iteration length for animated components which use the default
          <span class="inline-code">viewModel</span> (if they do not have a <span class="inline-code">viewModel</span> specified then it uses the default).</div>
      </div>
<pre><code class="javascript">fw.settings.sequenceAnimations = 100; // Set time between iterations to 100ms for default viewModels

// Note that you can also dynamically change the sequence timing by providing a callback
// Each time a new item is created the callback is triggered to determine the sequenceAnimations value
fw.settings.sequenceAnimations = function() {
  return 100; // Set time between iterations to 100ms via callback
}</code></pre>

      <p>If you are using your own <span class="inline-code"><a data-bind="$route: docLink('viewModel#fw-viewModel-create')">viewModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('dataModel#fw-dataModel-create')">dataModel</a></span> /
        <span class="inline-code"><a data-bind="$route: docLink('router#fw-router-create')">router</a></span> then you can specify a different
        <span class="inline-code">sequenceAnimations</span> value that is specific to it. See their respective <span class="inline-code">sequenceAnimations</span>
        configuration option.</p>
    </div>
  </section>

  <a id="misc" class="section-anchor" data-bind="sectionAnchor"></a>
  <section data-name="misc">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Utility / Misc</h1>
    </header>
    <div class="content">
      <p>Various useful methods and utility functions for misc and debugging purposes.</p>

      <a id="components-isRegistered" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.isRegistered<span>( <span class="param">'componentName'</span> )</span></div>
        </div>
        <div class="description">Returns <span class="inline-code">true</span> or <span class="inline-code">false</span> based on whether or not there
          is a <span class="inline-code">component</span> that has been registered under <span class="inline-code">componentName</span>.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">boolean</span> TRUE or FALSE depending on whether or not the specified componentName has been registered
            as a <span class="inline-code">component</span>.</span>
        </div>
      </div>
<pre><code class="javascript">fw.components.register('Sprocket', {
  viewModel: fw.viewModel.create({ /* ... configuration object ... */ }),
  template: '&lt;div&gt;&lt;-- template HTML --&gt;&lt;/div&gt;'
});
// fw.components.isRegistered('Sprocket') === true
// fw.components.isRegistered('SomeOtherComponent') === false</code></pre>

      <a id="components-getLocation" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.getLocation<span>( <span class="param">'componentName'</span> )</span></div>
        </div>
        <div class="description">Get the path Footwork will attempt to load for the given <span class="inline-code">componentName</span>.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">'string'</span> Path to the module</span>
        </div>
      </div>
<pre><code class="javascript">fw.components.registerLocation('Sprocket', {
  viewModel: '/components/bikeParts/',
  template: '/components/bikeParts/'
});

var sprocketLocation = fw.components.getLocation('Sprocket');
/**
 * sprocketLocation === {
 *   combined: null,
 *   viewModel: '/viewModel/bikeParts/',
 *   template: '/component/bikeParts/'
 * }
 */</code></pre>

      <a id="components-getFileName" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.getFileName<span>( <span class="param">'componentName'</span>, <span class="param">'[fileType]'</span> )</span></div>
        </div>
        <div class="description">Get the file name that Footwork will use when looking up the specified <span class="inline-code">fileType</span> for the
          <span class="inline-code">componentName</span>.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">'string'</span> Filename of the module</span>
        </div>
      </div>
<pre><code class="javascript">// get the template filename for the component 'sprocket'
var fileNameForSprocket = fw.components.getFileName('sprocket', 'template'); // === sprocket.html

// get the viewModel module filename for the component 'sprocket'
var fileNameForSprocket = fw.components.getFileName('sprocket', 'viewModel'); // === sprocket.js

// get the combined module filename for the component 'sprocket'
var fileNameForSprocket = fw.components.getFileName('sprocket', 'combined'); // === sprocket.js

/**
 * If the component was explicitly registered (cached), then null is returned for any
 * fileType because the file name will never be used.
 */
fw.components.register('sprocket', {
  viewModel: fw.viewModel.create({ /* ... configuration object ... */ }),
  template: '&lt;div&gt;&lt;!-- template HTML --&gt;&lt;/div&gt;'
});
var fileNameForSprocket = fw.components.getFileName('sprocket', 'viewModel'); // === null
</code></pre>

      <a id="components-fileExtensions" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.fileExtensions<span>( <span class="param">optionsObject</span> )</span></div>
          <div class="func-def"><span>fw.components</span>.fileExtensions<span>( <span class="param">function(componentName) { ... }</span> )</span></div>
        </div>
        <div class="description">Specify the extension to append to an AMD/RequireJS loaded <span class="inline-code">component</span> path when it does not have an extension specified (ie: full file name not specified).</div>
      </div>
<pre><code class="javascript">// explicitly set the extensions on the various file/module types
fw.viewModel.fileExtensions({
  combined: '.js', // append combined component files with '.js'
  viewModel: '.js', // append viewModel module files with '.js'
  template: '.html' // append template files with '.html'
});

// Specify a function() whose return configuration object is used to determine the extension:
fw.components.fileExtensions(function(componentName) {
  if(componentName === 'Sprocket') {
    return {
      combined: '.js', // append combined component files with '.js'
      viewModel: '.js', // append viewModel module files with '.js'
      template: '.html' // append template files with '.html'
    };
  } else {
    return {
      combined: '.other-js', // append combined component files with '.other-js'
      viewModel: '.other-js', // append viewModel module files with '.other-js'
      template: '.other-html' // append template files with '.other-html'
    };
  }
});</code></pre>

      <a id="components-getNormalTagList" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.getNormalTagList<span>()</span></div>
        </div>
        <div class="description">Return an array containing the list of elements (tagName) that Footwork will not process as a component.</div>
        <div class="return-value">
          <span class="label">Returns:</span>
          <span class="value"><span class="type">array[]</span> List of tagNames which are 'normal' HTML tags</span>
        </div>
      </div>
<pre><code class="javascript">var normalTags = fw.components.getNormalTagList(); // [ 'span', 'div', ... ]</code></pre>

      <a id="components-tagIsComponent" class="section-anchor" data-bind="sectionAnchor"></a>
      <div class="ref-block">
        <div class="title">
          <div class="type"><span class="icon icon-code"></span></div>
          <div class="func-def"><span>fw.components</span>.tagIsComponent<span>( <span class="param">'tagName'</span>, <span class="param">isComponent</span> )</span></div>
        </div>
        <div class="description">Flag a tagName as being a <span class="inline-code">component</span> (<span class="inline-code">true</span>) or not
          being a component (<span class="inline-code">false</span>).</div>
      </div>
<pre><code class="javascript">// tell Footwork not to process &lt;some-element&gt; as a component
fw.components.tagIsComponent('some-element', false);</code></pre>
    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "Components",
  "description": "Modularize and encapsulate sections of your application. Create different views it can use.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "usage",
          "title": "Usage",
          "subSections": [
            { "anchor": "load-register",
              "title": "Registering and Loading" },
            { "anchor": "module-formats",
              "title": "Module Formats" },
            { "anchor": "lifecycle",
              "title": "Lifecycle" },
            { "anchor": "animating-components",
              "title": "Animating Components",
              "description": "How to animate in loaded components." }
          ] }
      ] },
    { "anchor": "misc",
      "title": "Utility / Misc" }
  ],
  "apiReferences": [
    {
      "label": "",
      "subCategories": [
        {
          "label": "General",
          "references": [
            { "anchor": "fw-component",
              "title": "fw.component()",
              "description": "Create a combined component definition based on the provided viewModel / dataModel / router + template definition." }
          ]
        }, {
          "label": "Misc",
          "references": [
            { "anchor": "fw-settings-sequenceAnimations",
              "title": "fw.settings.sequenceAnimations",
              "description": "Variable which stores the default sequence iteration length for animated components which use the default viewModel." }
          ]
        }
      ]
    },
    {
      "label": "Registration",
      "subCategories": [
        {
          "label": "Methods",
          "references": [
            { "anchor": "components-register",
              "title": "fw.components.register()",
              "description": "Register (cache) a component under a specified 'name' for later use." },
            { "anchor": "components-isRegistered",
              "title": "fw.components.isRegistered()",
              "description": "Returns true or false based on whether or not there is a component that has been registered under componentName." },
            { "anchor": "components-registerLocation",
              "title": "fw.components.registerLocation()",
              "description": "Tell Footwork where to find the component name using the supplied configuration." }
          ]
        }
      ]
    },
    {
      "label": "Resource",
      "subCategories": [
        {
          "label": "Methods",
          "references": [
            { "anchor": "components-getLocation",
              "title": "fw.components.getLocation()",
              "description": "Get the path Footwork will attempt to load for the given componentName" },
            { "anchor": "components-getFileName",
              "title": "fw.components.getFileName()",
              "description": "Get the file name that Footwork will use when looking up the specified fileType for the componentName" },
            { "anchor": "components-defaultLocation",
              "title": "fw.components.defaultLocation()",
              "description": "Tell Footwork where to look for a component if it isn't registered explicitly (ie: when all else fails)." },
            { "anchor": "components-fileExtensions",
              "title": "fw.components.fileExtensions()",
              "description": "Specify the extension to append to an AMD/RequireJS loaded component path when it does not have an extension specified (ie: full file name not specified)." },
            { "anchor": "components-getNormalTagList",
              "title": "fw.components.getNormalTagList()",
              "description": "Return an array containing the list of elements (tagName) that Footwork will not process as a component." },
            { "anchor": "components-tagIsComponent",
              "title": "fw.components.tagIsComponent()",
              "description": "Flag a tagName as being a component (true) or not being a component (false)." }
          ]
        }
      ]
    }
  ]
}
</div>
